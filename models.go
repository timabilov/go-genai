// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by the Google Gen AI SDK generator DO NOT EDIT.

package genai

import (
	"context"
	"fmt"
	"iter"
	"net/http"
)

func partToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"videoMetadata"}) != nil {
		return nil, fmt.Errorf("videoMetadata parameter is not supported in Gemini API")
	}

	fromThought := getValueByPath(fromObject, []string{"thought"})
	if fromThought != nil {
		setValueByPath(toObject, []string{"thought"}, fromThought)
	}

	fromCodeExecutionResult := getValueByPath(fromObject, []string{"codeExecutionResult"})
	if fromCodeExecutionResult != nil {
		setValueByPath(toObject, []string{"codeExecutionResult"}, fromCodeExecutionResult)
	}

	fromExecutableCode := getValueByPath(fromObject, []string{"executableCode"})
	if fromExecutableCode != nil {
		setValueByPath(toObject, []string{"executableCode"}, fromExecutableCode)
	}

	fromFileData := getValueByPath(fromObject, []string{"fileData"})
	if fromFileData != nil {
		setValueByPath(toObject, []string{"fileData"}, fromFileData)
	}

	fromFunctionCall := getValueByPath(fromObject, []string{"functionCall"})
	if fromFunctionCall != nil {
		setValueByPath(toObject, []string{"functionCall"}, fromFunctionCall)
	}

	fromFunctionResponse := getValueByPath(fromObject, []string{"functionResponse"})
	if fromFunctionResponse != nil {
		setValueByPath(toObject, []string{"functionResponse"}, fromFunctionResponse)
	}

	fromInlineData := getValueByPath(fromObject, []string{"inlineData"})
	if fromInlineData != nil {
		setValueByPath(toObject, []string{"inlineData"}, fromInlineData)
	}

	fromText := getValueByPath(fromObject, []string{"text"})
	if fromText != nil {
		setValueByPath(toObject, []string{"text"}, fromText)
	}

	return toObject, nil
}

func partToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromVideoMetadata := getValueByPath(fromObject, []string{"videoMetadata"})
	if fromVideoMetadata != nil {
		setValueByPath(toObject, []string{"videoMetadata"}, fromVideoMetadata)
	}

	fromThought := getValueByPath(fromObject, []string{"thought"})
	if fromThought != nil {
		setValueByPath(toObject, []string{"thought"}, fromThought)
	}

	fromCodeExecutionResult := getValueByPath(fromObject, []string{"codeExecutionResult"})
	if fromCodeExecutionResult != nil {
		setValueByPath(toObject, []string{"codeExecutionResult"}, fromCodeExecutionResult)
	}

	fromExecutableCode := getValueByPath(fromObject, []string{"executableCode"})
	if fromExecutableCode != nil {
		setValueByPath(toObject, []string{"executableCode"}, fromExecutableCode)
	}

	fromFileData := getValueByPath(fromObject, []string{"fileData"})
	if fromFileData != nil {
		setValueByPath(toObject, []string{"fileData"}, fromFileData)
	}

	fromFunctionCall := getValueByPath(fromObject, []string{"functionCall"})
	if fromFunctionCall != nil {
		setValueByPath(toObject, []string{"functionCall"}, fromFunctionCall)
	}

	fromFunctionResponse := getValueByPath(fromObject, []string{"functionResponse"})
	if fromFunctionResponse != nil {
		setValueByPath(toObject, []string{"functionResponse"}, fromFunctionResponse)
	}

	fromInlineData := getValueByPath(fromObject, []string{"inlineData"})
	if fromInlineData != nil {
		setValueByPath(toObject, []string{"inlineData"}, fromInlineData)
	}

	fromText := getValueByPath(fromObject, []string{"text"})
	if fromText != nil {
		setValueByPath(toObject, []string{"text"}, fromText)
	}

	return toObject, nil
}

func contentToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromParts := getValueByPath(fromObject, []string{"parts"})
	if fromParts != nil {
		fromParts, err = applyConverterToSlice(ac, fromParts.([]any), partToMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"parts"}, fromParts)
	}

	fromRole := getValueByPath(fromObject, []string{"role"})
	if fromRole != nil {
		setValueByPath(toObject, []string{"role"}, fromRole)
	}

	return toObject, nil
}

func contentToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromParts := getValueByPath(fromObject, []string{"parts"})
	if fromParts != nil {
		fromParts, err = applyConverterToSlice(ac, fromParts.([]any), partToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"parts"}, fromParts)
	}

	fromRole := getValueByPath(fromObject, []string{"role"})
	if fromRole != nil {
		setValueByPath(toObject, []string{"role"}, fromRole)
	}

	return toObject, nil
}

func schemaToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"example"}) != nil {
		return nil, fmt.Errorf("example parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"pattern"}) != nil {
		return nil, fmt.Errorf("pattern parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"default"}) != nil {
		return nil, fmt.Errorf("default parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"maxLength"}) != nil {
		return nil, fmt.Errorf("maxLength parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"title"}) != nil {
		return nil, fmt.Errorf("title parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"minLength"}) != nil {
		return nil, fmt.Errorf("minLength parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"minProperties"}) != nil {
		return nil, fmt.Errorf("minProperties parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"maxProperties"}) != nil {
		return nil, fmt.Errorf("maxProperties parameter is not supported in Gemini API")
	}

	fromAnyOf := getValueByPath(fromObject, []string{"anyOf"})
	if fromAnyOf != nil {
		setValueByPath(toObject, []string{"anyOf"}, fromAnyOf)
	}

	fromDescription := getValueByPath(fromObject, []string{"description"})
	if fromDescription != nil {
		setValueByPath(toObject, []string{"description"}, fromDescription)
	}

	fromEnum := getValueByPath(fromObject, []string{"enum"})
	if fromEnum != nil {
		setValueByPath(toObject, []string{"enum"}, fromEnum)
	}

	fromFormat := getValueByPath(fromObject, []string{"format"})
	if fromFormat != nil {
		setValueByPath(toObject, []string{"format"}, fromFormat)
	}

	fromItems := getValueByPath(fromObject, []string{"items"})
	if fromItems != nil {
		setValueByPath(toObject, []string{"items"}, fromItems)
	}

	fromMaxItems := getValueByPath(fromObject, []string{"maxItems"})
	if fromMaxItems != nil {
		setValueByPath(toObject, []string{"maxItems"}, fromMaxItems)
	}

	fromMaximum := getValueByPath(fromObject, []string{"maximum"})
	if fromMaximum != nil {
		setValueByPath(toObject, []string{"maximum"}, fromMaximum)
	}

	fromMinItems := getValueByPath(fromObject, []string{"minItems"})
	if fromMinItems != nil {
		setValueByPath(toObject, []string{"minItems"}, fromMinItems)
	}

	fromMinimum := getValueByPath(fromObject, []string{"minimum"})
	if fromMinimum != nil {
		setValueByPath(toObject, []string{"minimum"}, fromMinimum)
	}

	fromNullable := getValueByPath(fromObject, []string{"nullable"})
	if fromNullable != nil {
		setValueByPath(toObject, []string{"nullable"}, fromNullable)
	}

	fromProperties := getValueByPath(fromObject, []string{"properties"})
	if fromProperties != nil {
		setValueByPath(toObject, []string{"properties"}, fromProperties)
	}

	fromPropertyOrdering := getValueByPath(fromObject, []string{"propertyOrdering"})
	if fromPropertyOrdering != nil {
		setValueByPath(toObject, []string{"propertyOrdering"}, fromPropertyOrdering)
	}

	fromRequired := getValueByPath(fromObject, []string{"required"})
	if fromRequired != nil {
		setValueByPath(toObject, []string{"required"}, fromRequired)
	}

	fromType := getValueByPath(fromObject, []string{"type"})
	if fromType != nil {
		setValueByPath(toObject, []string{"type"}, fromType)
	}

	return toObject, nil
}

func schemaToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromExample := getValueByPath(fromObject, []string{"example"})
	if fromExample != nil {
		setValueByPath(toObject, []string{"example"}, fromExample)
	}

	fromPattern := getValueByPath(fromObject, []string{"pattern"})
	if fromPattern != nil {
		setValueByPath(toObject, []string{"pattern"}, fromPattern)
	}

	fromDefault := getValueByPath(fromObject, []string{"default"})
	if fromDefault != nil {
		setValueByPath(toObject, []string{"default"}, fromDefault)
	}

	fromMaxLength := getValueByPath(fromObject, []string{"maxLength"})
	if fromMaxLength != nil {
		setValueByPath(toObject, []string{"maxLength"}, fromMaxLength)
	}

	fromTitle := getValueByPath(fromObject, []string{"title"})
	if fromTitle != nil {
		setValueByPath(toObject, []string{"title"}, fromTitle)
	}

	fromMinLength := getValueByPath(fromObject, []string{"minLength"})
	if fromMinLength != nil {
		setValueByPath(toObject, []string{"minLength"}, fromMinLength)
	}

	fromMinProperties := getValueByPath(fromObject, []string{"minProperties"})
	if fromMinProperties != nil {
		setValueByPath(toObject, []string{"minProperties"}, fromMinProperties)
	}

	fromMaxProperties := getValueByPath(fromObject, []string{"maxProperties"})
	if fromMaxProperties != nil {
		setValueByPath(toObject, []string{"maxProperties"}, fromMaxProperties)
	}

	fromAnyOf := getValueByPath(fromObject, []string{"anyOf"})
	if fromAnyOf != nil {
		setValueByPath(toObject, []string{"anyOf"}, fromAnyOf)
	}

	fromDescription := getValueByPath(fromObject, []string{"description"})
	if fromDescription != nil {
		setValueByPath(toObject, []string{"description"}, fromDescription)
	}

	fromEnum := getValueByPath(fromObject, []string{"enum"})
	if fromEnum != nil {
		setValueByPath(toObject, []string{"enum"}, fromEnum)
	}

	fromFormat := getValueByPath(fromObject, []string{"format"})
	if fromFormat != nil {
		setValueByPath(toObject, []string{"format"}, fromFormat)
	}

	fromItems := getValueByPath(fromObject, []string{"items"})
	if fromItems != nil {
		setValueByPath(toObject, []string{"items"}, fromItems)
	}

	fromMaxItems := getValueByPath(fromObject, []string{"maxItems"})
	if fromMaxItems != nil {
		setValueByPath(toObject, []string{"maxItems"}, fromMaxItems)
	}

	fromMaximum := getValueByPath(fromObject, []string{"maximum"})
	if fromMaximum != nil {
		setValueByPath(toObject, []string{"maximum"}, fromMaximum)
	}

	fromMinItems := getValueByPath(fromObject, []string{"minItems"})
	if fromMinItems != nil {
		setValueByPath(toObject, []string{"minItems"}, fromMinItems)
	}

	fromMinimum := getValueByPath(fromObject, []string{"minimum"})
	if fromMinimum != nil {
		setValueByPath(toObject, []string{"minimum"}, fromMinimum)
	}

	fromNullable := getValueByPath(fromObject, []string{"nullable"})
	if fromNullable != nil {
		setValueByPath(toObject, []string{"nullable"}, fromNullable)
	}

	fromProperties := getValueByPath(fromObject, []string{"properties"})
	if fromProperties != nil {
		setValueByPath(toObject, []string{"properties"}, fromProperties)
	}

	fromPropertyOrdering := getValueByPath(fromObject, []string{"propertyOrdering"})
	if fromPropertyOrdering != nil {
		setValueByPath(toObject, []string{"propertyOrdering"}, fromPropertyOrdering)
	}

	fromRequired := getValueByPath(fromObject, []string{"required"})
	if fromRequired != nil {
		setValueByPath(toObject, []string{"required"}, fromRequired)
	}

	fromType := getValueByPath(fromObject, []string{"type"})
	if fromType != nil {
		setValueByPath(toObject, []string{"type"}, fromType)
	}

	return toObject, nil
}

func safetySettingToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"method"}) != nil {
		return nil, fmt.Errorf("method parameter is not supported in Gemini API")
	}

	fromCategory := getValueByPath(fromObject, []string{"category"})
	if fromCategory != nil {
		setValueByPath(toObject, []string{"category"}, fromCategory)
	}

	fromThreshold := getValueByPath(fromObject, []string{"threshold"})
	if fromThreshold != nil {
		setValueByPath(toObject, []string{"threshold"}, fromThreshold)
	}

	return toObject, nil
}

func safetySettingToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromMethod := getValueByPath(fromObject, []string{"method"})
	if fromMethod != nil {
		setValueByPath(toObject, []string{"method"}, fromMethod)
	}

	fromCategory := getValueByPath(fromObject, []string{"category"})
	if fromCategory != nil {
		setValueByPath(toObject, []string{"category"}, fromCategory)
	}

	fromThreshold := getValueByPath(fromObject, []string{"threshold"})
	if fromThreshold != nil {
		setValueByPath(toObject, []string{"threshold"}, fromThreshold)
	}

	return toObject, nil
}

func functionDeclarationToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"response"}) != nil {
		return nil, fmt.Errorf("response parameter is not supported in Gemini API")
	}

	fromDescription := getValueByPath(fromObject, []string{"description"})
	if fromDescription != nil {
		setValueByPath(toObject, []string{"description"}, fromDescription)
	}

	fromName := getValueByPath(fromObject, []string{"name"})
	if fromName != nil {
		setValueByPath(toObject, []string{"name"}, fromName)
	}

	fromParameters := getValueByPath(fromObject, []string{"parameters"})
	if fromParameters != nil {
		setValueByPath(toObject, []string{"parameters"}, fromParameters)
	}

	return toObject, nil
}

func functionDeclarationToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromResponse := getValueByPath(fromObject, []string{"response"})
	if fromResponse != nil {
		fromResponse, err = schemaToVertex(ac, fromResponse.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"response"}, fromResponse)
	}

	fromDescription := getValueByPath(fromObject, []string{"description"})
	if fromDescription != nil {
		setValueByPath(toObject, []string{"description"}, fromDescription)
	}

	fromName := getValueByPath(fromObject, []string{"name"})
	if fromName != nil {
		setValueByPath(toObject, []string{"name"}, fromName)
	}

	fromParameters := getValueByPath(fromObject, []string{"parameters"})
	if fromParameters != nil {
		setValueByPath(toObject, []string{"parameters"}, fromParameters)
	}

	return toObject, nil
}

func googleSearchToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	return toObject, nil
}

func googleSearchToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	return toObject, nil
}

func dynamicRetrievalConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromMode := getValueByPath(fromObject, []string{"mode"})
	if fromMode != nil {
		setValueByPath(toObject, []string{"mode"}, fromMode)
	}

	fromDynamicThreshold := getValueByPath(fromObject, []string{"dynamicThreshold"})
	if fromDynamicThreshold != nil {
		setValueByPath(toObject, []string{"dynamicThreshold"}, fromDynamicThreshold)
	}

	return toObject, nil
}

func dynamicRetrievalConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromMode := getValueByPath(fromObject, []string{"mode"})
	if fromMode != nil {
		setValueByPath(toObject, []string{"mode"}, fromMode)
	}

	fromDynamicThreshold := getValueByPath(fromObject, []string{"dynamicThreshold"})
	if fromDynamicThreshold != nil {
		setValueByPath(toObject, []string{"dynamicThreshold"}, fromDynamicThreshold)
	}

	return toObject, nil
}

func googleSearchRetrievalToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromDynamicRetrievalConfig := getValueByPath(fromObject, []string{"dynamicRetrievalConfig"})
	if fromDynamicRetrievalConfig != nil {
		fromDynamicRetrievalConfig, err = dynamicRetrievalConfigToMldev(ac, fromDynamicRetrievalConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"dynamicRetrievalConfig"}, fromDynamicRetrievalConfig)
	}

	return toObject, nil
}

func googleSearchRetrievalToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromDynamicRetrievalConfig := getValueByPath(fromObject, []string{"dynamicRetrievalConfig"})
	if fromDynamicRetrievalConfig != nil {
		fromDynamicRetrievalConfig, err = dynamicRetrievalConfigToVertex(ac, fromDynamicRetrievalConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"dynamicRetrievalConfig"}, fromDynamicRetrievalConfig)
	}

	return toObject, nil
}

func toolToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromFunctionDeclarations := getValueByPath(fromObject, []string{"functionDeclarations"})
	if fromFunctionDeclarations != nil {
		fromFunctionDeclarations, err = applyConverterToSlice(ac, fromFunctionDeclarations.([]any), functionDeclarationToMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"functionDeclarations"}, fromFunctionDeclarations)
	}

	if getValueByPath(fromObject, []string{"retrieval"}) != nil {
		return nil, fmt.Errorf("retrieval parameter is not supported in Gemini API")
	}

	fromGoogleSearch := getValueByPath(fromObject, []string{"googleSearch"})
	if fromGoogleSearch != nil {
		fromGoogleSearch, err = googleSearchToMldev(ac, fromGoogleSearch.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"googleSearch"}, fromGoogleSearch)
	}

	fromGoogleSearchRetrieval := getValueByPath(fromObject, []string{"googleSearchRetrieval"})
	if fromGoogleSearchRetrieval != nil {
		fromGoogleSearchRetrieval, err = googleSearchRetrievalToMldev(ac, fromGoogleSearchRetrieval.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"googleSearchRetrieval"}, fromGoogleSearchRetrieval)
	}

	fromCodeExecution := getValueByPath(fromObject, []string{"codeExecution"})
	if fromCodeExecution != nil {
		setValueByPath(toObject, []string{"codeExecution"}, fromCodeExecution)
	}

	return toObject, nil
}

func toolToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromFunctionDeclarations := getValueByPath(fromObject, []string{"functionDeclarations"})
	if fromFunctionDeclarations != nil {
		fromFunctionDeclarations, err = applyConverterToSlice(ac, fromFunctionDeclarations.([]any), functionDeclarationToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"functionDeclarations"}, fromFunctionDeclarations)
	}

	fromRetrieval := getValueByPath(fromObject, []string{"retrieval"})
	if fromRetrieval != nil {
		setValueByPath(toObject, []string{"retrieval"}, fromRetrieval)
	}

	fromGoogleSearch := getValueByPath(fromObject, []string{"googleSearch"})
	if fromGoogleSearch != nil {
		fromGoogleSearch, err = googleSearchToVertex(ac, fromGoogleSearch.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"googleSearch"}, fromGoogleSearch)
	}

	fromGoogleSearchRetrieval := getValueByPath(fromObject, []string{"googleSearchRetrieval"})
	if fromGoogleSearchRetrieval != nil {
		fromGoogleSearchRetrieval, err = googleSearchRetrievalToVertex(ac, fromGoogleSearchRetrieval.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"googleSearchRetrieval"}, fromGoogleSearchRetrieval)
	}

	fromCodeExecution := getValueByPath(fromObject, []string{"codeExecution"})
	if fromCodeExecution != nil {
		setValueByPath(toObject, []string{"codeExecution"}, fromCodeExecution)
	}

	return toObject, nil
}

func functionCallingConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromMode := getValueByPath(fromObject, []string{"mode"})
	if fromMode != nil {
		setValueByPath(toObject, []string{"mode"}, fromMode)
	}

	fromAllowedFunctionNames := getValueByPath(fromObject, []string{"allowedFunctionNames"})
	if fromAllowedFunctionNames != nil {
		setValueByPath(toObject, []string{"allowedFunctionNames"}, fromAllowedFunctionNames)
	}

	return toObject, nil
}

func functionCallingConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromMode := getValueByPath(fromObject, []string{"mode"})
	if fromMode != nil {
		setValueByPath(toObject, []string{"mode"}, fromMode)
	}

	fromAllowedFunctionNames := getValueByPath(fromObject, []string{"allowedFunctionNames"})
	if fromAllowedFunctionNames != nil {
		setValueByPath(toObject, []string{"allowedFunctionNames"}, fromAllowedFunctionNames)
	}

	return toObject, nil
}

func toolConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromFunctionCallingConfig := getValueByPath(fromObject, []string{"functionCallingConfig"})
	if fromFunctionCallingConfig != nil {
		fromFunctionCallingConfig, err = functionCallingConfigToMldev(ac, fromFunctionCallingConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"functionCallingConfig"}, fromFunctionCallingConfig)
	}

	return toObject, nil
}

func toolConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromFunctionCallingConfig := getValueByPath(fromObject, []string{"functionCallingConfig"})
	if fromFunctionCallingConfig != nil {
		fromFunctionCallingConfig, err = functionCallingConfigToVertex(ac, fromFunctionCallingConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"functionCallingConfig"}, fromFunctionCallingConfig)
	}

	return toObject, nil
}

func prebuiltVoiceConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromVoiceName := getValueByPath(fromObject, []string{"voiceName"})
	if fromVoiceName != nil {
		setValueByPath(toObject, []string{"voiceName"}, fromVoiceName)
	}

	return toObject, nil
}

func prebuiltVoiceConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromVoiceName := getValueByPath(fromObject, []string{"voiceName"})
	if fromVoiceName != nil {
		setValueByPath(toObject, []string{"voiceName"}, fromVoiceName)
	}

	return toObject, nil
}

func voiceConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromPrebuiltVoiceConfig := getValueByPath(fromObject, []string{"prebuiltVoiceConfig"})
	if fromPrebuiltVoiceConfig != nil {
		fromPrebuiltVoiceConfig, err = prebuiltVoiceConfigToMldev(ac, fromPrebuiltVoiceConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"prebuiltVoiceConfig"}, fromPrebuiltVoiceConfig)
	}

	return toObject, nil
}

func voiceConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromPrebuiltVoiceConfig := getValueByPath(fromObject, []string{"prebuiltVoiceConfig"})
	if fromPrebuiltVoiceConfig != nil {
		fromPrebuiltVoiceConfig, err = prebuiltVoiceConfigToVertex(ac, fromPrebuiltVoiceConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"prebuiltVoiceConfig"}, fromPrebuiltVoiceConfig)
	}

	return toObject, nil
}

func speechConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromVoiceConfig := getValueByPath(fromObject, []string{"voiceConfig"})
	if fromVoiceConfig != nil {
		fromVoiceConfig, err = voiceConfigToMldev(ac, fromVoiceConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"voiceConfig"}, fromVoiceConfig)
	}

	return toObject, nil
}

func speechConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromVoiceConfig := getValueByPath(fromObject, []string{"voiceConfig"})
	if fromVoiceConfig != nil {
		fromVoiceConfig, err = voiceConfigToVertex(ac, fromVoiceConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"voiceConfig"}, fromVoiceConfig)
	}

	return toObject, nil
}

func thinkingConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromIncludeThoughts := getValueByPath(fromObject, []string{"includeThoughts"})
	if fromIncludeThoughts != nil {
		setValueByPath(toObject, []string{"includeThoughts"}, fromIncludeThoughts)
	}

	return toObject, nil
}

func thinkingConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromIncludeThoughts := getValueByPath(fromObject, []string{"includeThoughts"})
	if fromIncludeThoughts != nil {
		setValueByPath(toObject, []string{"includeThoughts"}, fromIncludeThoughts)
	}

	return toObject, nil
}

func generateContentConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromSystemInstruction := getValueByPath(fromObject, []string{"systemInstruction"})
	if fromSystemInstruction != nil {
		fromSystemInstruction, err = tContent(ac, fromSystemInstruction)
		if err != nil {
			return nil, err
		}

		fromSystemInstruction, err = contentToMldev(ac, fromSystemInstruction.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"systemInstruction"}, fromSystemInstruction)
	}

	fromTemperature := getValueByPath(fromObject, []string{"temperature"})
	if fromTemperature != nil {
		setValueByPath(toObject, []string{"temperature"}, fromTemperature)
	}

	fromTopP := getValueByPath(fromObject, []string{"topP"})
	if fromTopP != nil {
		setValueByPath(toObject, []string{"topP"}, fromTopP)
	}

	fromTopK := getValueByPath(fromObject, []string{"topK"})
	if fromTopK != nil {
		setValueByPath(toObject, []string{"topK"}, fromTopK)
	}

	fromCandidateCount := getValueByPath(fromObject, []string{"candidateCount"})
	if fromCandidateCount != nil {
		setValueByPath(toObject, []string{"candidateCount"}, fromCandidateCount)
	}

	fromMaxOutputTokens := getValueByPath(fromObject, []string{"maxOutputTokens"})
	if fromMaxOutputTokens != nil {
		setValueByPath(toObject, []string{"maxOutputTokens"}, fromMaxOutputTokens)
	}

	fromStopSequences := getValueByPath(fromObject, []string{"stopSequences"})
	if fromStopSequences != nil {
		setValueByPath(toObject, []string{"stopSequences"}, fromStopSequences)
	}

	fromResponseLogprobs := getValueByPath(fromObject, []string{"responseLogprobs"})
	if fromResponseLogprobs != nil {
		setValueByPath(toObject, []string{"responseLogprobs"}, fromResponseLogprobs)
	}

	fromLogprobs := getValueByPath(fromObject, []string{"logprobs"})
	if fromLogprobs != nil {
		setValueByPath(toObject, []string{"logprobs"}, fromLogprobs)
	}

	fromPresencePenalty := getValueByPath(fromObject, []string{"presencePenalty"})
	if fromPresencePenalty != nil {
		setValueByPath(toObject, []string{"presencePenalty"}, fromPresencePenalty)
	}

	fromFrequencyPenalty := getValueByPath(fromObject, []string{"frequencyPenalty"})
	if fromFrequencyPenalty != nil {
		setValueByPath(toObject, []string{"frequencyPenalty"}, fromFrequencyPenalty)
	}

	fromSeed := getValueByPath(fromObject, []string{"seed"})
	if fromSeed != nil {
		setValueByPath(toObject, []string{"seed"}, fromSeed)
	}

	fromResponseMimeType := getValueByPath(fromObject, []string{"responseMimeType"})
	if fromResponseMimeType != nil {
		setValueByPath(toObject, []string{"responseMimeType"}, fromResponseMimeType)
	}

	fromResponseSchema := getValueByPath(fromObject, []string{"responseSchema"})
	if fromResponseSchema != nil {
		fromResponseSchema, err = tSchema(ac, fromResponseSchema)
		if err != nil {
			return nil, err
		}

		fromResponseSchema, err = schemaToMldev(ac, fromResponseSchema.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"responseSchema"}, fromResponseSchema)
	}

	if getValueByPath(fromObject, []string{"routingConfig"}) != nil {
		return nil, fmt.Errorf("routingConfig parameter is not supported in Gemini API")
	}

	fromSafetySettings := getValueByPath(fromObject, []string{"safetySettings"})
	if fromSafetySettings != nil {
		fromSafetySettings, err = applyConverterToSlice(ac, fromSafetySettings.([]any), safetySettingToMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"safetySettings"}, fromSafetySettings)
	}

	fromTools := getValueByPath(fromObject, []string{"tools"})
	if fromTools != nil {
		fromTools, err = applyItemTransformerToSlice(ac, fromTools.([]any), tTool)

		fromTools, err = tTools(ac, fromTools)
		if err != nil {
			return nil, err
		}

		fromTools, err = applyConverterToSlice(ac, fromTools.([]any), toolToMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"tools"}, fromTools)
	}

	fromToolConfig := getValueByPath(fromObject, []string{"toolConfig"})
	if fromToolConfig != nil {
		fromToolConfig, err = toolConfigToMldev(ac, fromToolConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"toolConfig"}, fromToolConfig)
	}

	if getValueByPath(fromObject, []string{"labels"}) != nil {
		return nil, fmt.Errorf("labels parameter is not supported in Gemini API")
	}

	fromCachedContent := getValueByPath(fromObject, []string{"cachedContent"})
	if fromCachedContent != nil {
		fromCachedContent, err = tCachedContentName(ac, fromCachedContent)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"cachedContent"}, fromCachedContent)
	}

	fromResponseModalities := getValueByPath(fromObject, []string{"responseModalities"})
	if fromResponseModalities != nil {
		setValueByPath(toObject, []string{"responseModalities"}, fromResponseModalities)
	}

	fromMediaResolution := getValueByPath(fromObject, []string{"mediaResolution"})
	if fromMediaResolution != nil {
		setValueByPath(toObject, []string{"mediaResolution"}, fromMediaResolution)
	}

	fromSpeechConfig := getValueByPath(fromObject, []string{"speechConfig"})
	if fromSpeechConfig != nil {
		fromSpeechConfig, err = tSpeechConfig(ac, fromSpeechConfig)
		if err != nil {
			return nil, err
		}

		fromSpeechConfig, err = speechConfigToMldev(ac, fromSpeechConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"speechConfig"}, fromSpeechConfig)
	}

	if getValueByPath(fromObject, []string{"audioTimestamp"}) != nil {
		return nil, fmt.Errorf("audioTimestamp parameter is not supported in Gemini API")
	}

	fromThinkingConfig := getValueByPath(fromObject, []string{"thinkingConfig"})
	if fromThinkingConfig != nil {
		fromThinkingConfig, err = thinkingConfigToMldev(ac, fromThinkingConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"thinkingConfig"}, fromThinkingConfig)
	}

	return toObject, nil
}

func generateContentConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromSystemInstruction := getValueByPath(fromObject, []string{"systemInstruction"})
	if fromSystemInstruction != nil {
		fromSystemInstruction, err = tContent(ac, fromSystemInstruction)
		if err != nil {
			return nil, err
		}

		fromSystemInstruction, err = contentToVertex(ac, fromSystemInstruction.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"systemInstruction"}, fromSystemInstruction)
	}

	fromTemperature := getValueByPath(fromObject, []string{"temperature"})
	if fromTemperature != nil {
		setValueByPath(toObject, []string{"temperature"}, fromTemperature)
	}

	fromTopP := getValueByPath(fromObject, []string{"topP"})
	if fromTopP != nil {
		setValueByPath(toObject, []string{"topP"}, fromTopP)
	}

	fromTopK := getValueByPath(fromObject, []string{"topK"})
	if fromTopK != nil {
		setValueByPath(toObject, []string{"topK"}, fromTopK)
	}

	fromCandidateCount := getValueByPath(fromObject, []string{"candidateCount"})
	if fromCandidateCount != nil {
		setValueByPath(toObject, []string{"candidateCount"}, fromCandidateCount)
	}

	fromMaxOutputTokens := getValueByPath(fromObject, []string{"maxOutputTokens"})
	if fromMaxOutputTokens != nil {
		setValueByPath(toObject, []string{"maxOutputTokens"}, fromMaxOutputTokens)
	}

	fromStopSequences := getValueByPath(fromObject, []string{"stopSequences"})
	if fromStopSequences != nil {
		setValueByPath(toObject, []string{"stopSequences"}, fromStopSequences)
	}

	fromResponseLogprobs := getValueByPath(fromObject, []string{"responseLogprobs"})
	if fromResponseLogprobs != nil {
		setValueByPath(toObject, []string{"responseLogprobs"}, fromResponseLogprobs)
	}

	fromLogprobs := getValueByPath(fromObject, []string{"logprobs"})
	if fromLogprobs != nil {
		setValueByPath(toObject, []string{"logprobs"}, fromLogprobs)
	}

	fromPresencePenalty := getValueByPath(fromObject, []string{"presencePenalty"})
	if fromPresencePenalty != nil {
		setValueByPath(toObject, []string{"presencePenalty"}, fromPresencePenalty)
	}

	fromFrequencyPenalty := getValueByPath(fromObject, []string{"frequencyPenalty"})
	if fromFrequencyPenalty != nil {
		setValueByPath(toObject, []string{"frequencyPenalty"}, fromFrequencyPenalty)
	}

	fromSeed := getValueByPath(fromObject, []string{"seed"})
	if fromSeed != nil {
		setValueByPath(toObject, []string{"seed"}, fromSeed)
	}

	fromResponseMimeType := getValueByPath(fromObject, []string{"responseMimeType"})
	if fromResponseMimeType != nil {
		setValueByPath(toObject, []string{"responseMimeType"}, fromResponseMimeType)
	}

	fromResponseSchema := getValueByPath(fromObject, []string{"responseSchema"})
	if fromResponseSchema != nil {
		fromResponseSchema, err = tSchema(ac, fromResponseSchema)
		if err != nil {
			return nil, err
		}

		fromResponseSchema, err = schemaToVertex(ac, fromResponseSchema.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"responseSchema"}, fromResponseSchema)
	}

	fromRoutingConfig := getValueByPath(fromObject, []string{"routingConfig"})
	if fromRoutingConfig != nil {
		setValueByPath(toObject, []string{"routingConfig"}, fromRoutingConfig)
	}

	fromSafetySettings := getValueByPath(fromObject, []string{"safetySettings"})
	if fromSafetySettings != nil {
		fromSafetySettings, err = applyConverterToSlice(ac, fromSafetySettings.([]any), safetySettingToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"safetySettings"}, fromSafetySettings)
	}

	fromTools := getValueByPath(fromObject, []string{"tools"})
	if fromTools != nil {
		fromTools, err = applyItemTransformerToSlice(ac, fromTools.([]any), tTool)

		fromTools, err = tTools(ac, fromTools)
		if err != nil {
			return nil, err
		}

		fromTools, err = applyConverterToSlice(ac, fromTools.([]any), toolToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"tools"}, fromTools)
	}

	fromToolConfig := getValueByPath(fromObject, []string{"toolConfig"})
	if fromToolConfig != nil {
		fromToolConfig, err = toolConfigToVertex(ac, fromToolConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"toolConfig"}, fromToolConfig)
	}

	fromLabels := getValueByPath(fromObject, []string{"labels"})
	if fromLabels != nil {
		setValueByPath(parentObject, []string{"labels"}, fromLabels)
	}

	fromCachedContent := getValueByPath(fromObject, []string{"cachedContent"})
	if fromCachedContent != nil {
		fromCachedContent, err = tCachedContentName(ac, fromCachedContent)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"cachedContent"}, fromCachedContent)
	}

	fromResponseModalities := getValueByPath(fromObject, []string{"responseModalities"})
	if fromResponseModalities != nil {
		setValueByPath(toObject, []string{"responseModalities"}, fromResponseModalities)
	}

	fromMediaResolution := getValueByPath(fromObject, []string{"mediaResolution"})
	if fromMediaResolution != nil {
		setValueByPath(toObject, []string{"mediaResolution"}, fromMediaResolution)
	}

	fromSpeechConfig := getValueByPath(fromObject, []string{"speechConfig"})
	if fromSpeechConfig != nil {
		fromSpeechConfig, err = tSpeechConfig(ac, fromSpeechConfig)
		if err != nil {
			return nil, err
		}

		fromSpeechConfig, err = speechConfigToVertex(ac, fromSpeechConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"speechConfig"}, fromSpeechConfig)
	}

	fromAudioTimestamp := getValueByPath(fromObject, []string{"audioTimestamp"})
	if fromAudioTimestamp != nil {
		setValueByPath(toObject, []string{"audioTimestamp"}, fromAudioTimestamp)
	}

	fromThinkingConfig := getValueByPath(fromObject, []string{"thinkingConfig"})
	if fromThinkingConfig != nil {
		fromThinkingConfig, err = thinkingConfigToVertex(ac, fromThinkingConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"thinkingConfig"}, fromThinkingConfig)
	}

	return toObject, nil
}

func generateContentParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromContents := getValueByPath(fromObject, []string{"contents"})
	if fromContents != nil {
		fromContents, err = tContents(ac, fromContents)
		if err != nil {
			return nil, err
		}

		fromContents, err = applyConverterToSlice(ac, fromContents.([]any), contentToMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"contents"}, fromContents)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = generateContentConfigToMldev(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"generationConfig"}, fromConfig)
	}

	return toObject, nil
}

func generateContentParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromContents := getValueByPath(fromObject, []string{"contents"})
	if fromContents != nil {
		fromContents, err = tContents(ac, fromContents)
		if err != nil {
			return nil, err
		}

		fromContents, err = applyConverterToSlice(ac, fromContents.([]any), contentToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"contents"}, fromContents)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = generateContentConfigToVertex(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"generationConfig"}, fromConfig)
	}

	return toObject, nil
}

func embedContentConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromTaskType := getValueByPath(fromObject, []string{"taskType"})
	if fromTaskType != nil {
		setValueByPath(parentObject, []string{"requests[]", "taskType"}, fromTaskType)
	}

	fromTitle := getValueByPath(fromObject, []string{"title"})
	if fromTitle != nil {
		setValueByPath(parentObject, []string{"requests[]", "title"}, fromTitle)
	}

	fromOutputDimensionality := getValueByPath(fromObject, []string{"outputDimensionality"})
	if fromOutputDimensionality != nil {
		setValueByPath(parentObject, []string{"requests[]", "outputDimensionality"}, fromOutputDimensionality)
	}

	if getValueByPath(fromObject, []string{"mimeType"}) != nil {
		return nil, fmt.Errorf("mimeType parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"autoTruncate"}) != nil {
		return nil, fmt.Errorf("autoTruncate parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func embedContentConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromTaskType := getValueByPath(fromObject, []string{"taskType"})
	if fromTaskType != nil {
		setValueByPath(parentObject, []string{"instances[]", "taskType"}, fromTaskType)
	}

	fromTitle := getValueByPath(fromObject, []string{"title"})
	if fromTitle != nil {
		setValueByPath(parentObject, []string{"instances[]", "title"}, fromTitle)
	}

	fromOutputDimensionality := getValueByPath(fromObject, []string{"outputDimensionality"})
	if fromOutputDimensionality != nil {
		setValueByPath(parentObject, []string{"parameters", "outputDimensionality"}, fromOutputDimensionality)
	}

	fromMimeType := getValueByPath(fromObject, []string{"mimeType"})
	if fromMimeType != nil {
		setValueByPath(parentObject, []string{"instances[]", "mimeType"}, fromMimeType)
	}

	fromAutoTruncate := getValueByPath(fromObject, []string{"autoTruncate"})
	if fromAutoTruncate != nil {
		setValueByPath(parentObject, []string{"parameters", "autoTruncate"}, fromAutoTruncate)
	}

	return toObject, nil
}

func embedContentParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromContents := getValueByPath(fromObject, []string{"contents"})
	if fromContents != nil {
		fromContents, err = tContentsForEmbed(ac, fromContents)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"requests[]", "content"}, fromContents)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = embedContentConfigToMldev(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	setValueByPath(toObject, []string{"requests[]", "model"}, fromModel)

	return toObject, nil
}

func embedContentParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromContents := getValueByPath(fromObject, []string{"contents"})
	if fromContents != nil {
		fromContents, err = tContentsForEmbed(ac, fromContents)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"instances[]", "content"}, fromContents)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = embedContentConfigToVertex(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func generateImagesConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	if getValueByPath(fromObject, []string{"outputGcsUri"}) != nil {
		return nil, fmt.Errorf("outputGcsUri parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"negativePrompt"}) != nil {
		return nil, fmt.Errorf("negativePrompt parameter is not supported in Gemini API")
	}

	fromNumberOfImages := getValueByPath(fromObject, []string{"numberOfImages"})
	if fromNumberOfImages != nil {
		setValueByPath(parentObject, []string{"parameters", "sampleCount"}, fromNumberOfImages)
	}

	fromAspectRatio := getValueByPath(fromObject, []string{"aspectRatio"})
	if fromAspectRatio != nil {
		setValueByPath(parentObject, []string{"parameters", "aspectRatio"}, fromAspectRatio)
	}

	fromGuidanceScale := getValueByPath(fromObject, []string{"guidanceScale"})
	if fromGuidanceScale != nil {
		setValueByPath(parentObject, []string{"parameters", "guidanceScale"}, fromGuidanceScale)
	}

	if getValueByPath(fromObject, []string{"seed"}) != nil {
		return nil, fmt.Errorf("seed parameter is not supported in Gemini API")
	}

	fromSafetyFilterLevel := getValueByPath(fromObject, []string{"safetyFilterLevel"})
	if fromSafetyFilterLevel != nil {
		setValueByPath(parentObject, []string{"parameters", "safetySetting"}, fromSafetyFilterLevel)
	}

	fromPersonGeneration := getValueByPath(fromObject, []string{"personGeneration"})
	if fromPersonGeneration != nil {
		setValueByPath(parentObject, []string{"parameters", "personGeneration"}, fromPersonGeneration)
	}

	fromIncludeSafetyAttributes := getValueByPath(fromObject, []string{"includeSafetyAttributes"})
	if fromIncludeSafetyAttributes != nil {
		setValueByPath(parentObject, []string{"parameters", "includeSafetyAttributes"}, fromIncludeSafetyAttributes)
	}

	fromIncludeRaiReason := getValueByPath(fromObject, []string{"includeRaiReason"})
	if fromIncludeRaiReason != nil {
		setValueByPath(parentObject, []string{"parameters", "includeRaiReason"}, fromIncludeRaiReason)
	}

	fromLanguage := getValueByPath(fromObject, []string{"language"})
	if fromLanguage != nil {
		setValueByPath(parentObject, []string{"parameters", "language"}, fromLanguage)
	}

	fromOutputMimeType := getValueByPath(fromObject, []string{"outputMimeType"})
	if fromOutputMimeType != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "mimeType"}, fromOutputMimeType)
	}

	fromOutputCompressionQuality := getValueByPath(fromObject, []string{"outputCompressionQuality"})
	if fromOutputCompressionQuality != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "compressionQuality"}, fromOutputCompressionQuality)
	}

	if getValueByPath(fromObject, []string{"addWatermark"}) != nil {
		return nil, fmt.Errorf("addWatermark parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"enhancePrompt"}) != nil {
		return nil, fmt.Errorf("enhancePrompt parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func generateImagesConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromOutputGcsUri := getValueByPath(fromObject, []string{"outputGcsUri"})
	if fromOutputGcsUri != nil {
		setValueByPath(parentObject, []string{"parameters", "storageUri"}, fromOutputGcsUri)
	}

	fromNegativePrompt := getValueByPath(fromObject, []string{"negativePrompt"})
	if fromNegativePrompt != nil {
		setValueByPath(parentObject, []string{"parameters", "negativePrompt"}, fromNegativePrompt)
	}

	fromNumberOfImages := getValueByPath(fromObject, []string{"numberOfImages"})
	if fromNumberOfImages != nil {
		setValueByPath(parentObject, []string{"parameters", "sampleCount"}, fromNumberOfImages)
	}

	fromAspectRatio := getValueByPath(fromObject, []string{"aspectRatio"})
	if fromAspectRatio != nil {
		setValueByPath(parentObject, []string{"parameters", "aspectRatio"}, fromAspectRatio)
	}

	fromGuidanceScale := getValueByPath(fromObject, []string{"guidanceScale"})
	if fromGuidanceScale != nil {
		setValueByPath(parentObject, []string{"parameters", "guidanceScale"}, fromGuidanceScale)
	}

	fromSeed := getValueByPath(fromObject, []string{"seed"})
	if fromSeed != nil {
		setValueByPath(parentObject, []string{"parameters", "seed"}, fromSeed)
	}

	fromSafetyFilterLevel := getValueByPath(fromObject, []string{"safetyFilterLevel"})
	if fromSafetyFilterLevel != nil {
		setValueByPath(parentObject, []string{"parameters", "safetySetting"}, fromSafetyFilterLevel)
	}

	fromPersonGeneration := getValueByPath(fromObject, []string{"personGeneration"})
	if fromPersonGeneration != nil {
		setValueByPath(parentObject, []string{"parameters", "personGeneration"}, fromPersonGeneration)
	}

	fromIncludeSafetyAttributes := getValueByPath(fromObject, []string{"includeSafetyAttributes"})
	if fromIncludeSafetyAttributes != nil {
		setValueByPath(parentObject, []string{"parameters", "includeSafetyAttributes"}, fromIncludeSafetyAttributes)
	}

	fromIncludeRaiReason := getValueByPath(fromObject, []string{"includeRaiReason"})
	if fromIncludeRaiReason != nil {
		setValueByPath(parentObject, []string{"parameters", "includeRaiReason"}, fromIncludeRaiReason)
	}

	fromLanguage := getValueByPath(fromObject, []string{"language"})
	if fromLanguage != nil {
		setValueByPath(parentObject, []string{"parameters", "language"}, fromLanguage)
	}

	fromOutputMimeType := getValueByPath(fromObject, []string{"outputMimeType"})
	if fromOutputMimeType != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "mimeType"}, fromOutputMimeType)
	}

	fromOutputCompressionQuality := getValueByPath(fromObject, []string{"outputCompressionQuality"})
	if fromOutputCompressionQuality != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "compressionQuality"}, fromOutputCompressionQuality)
	}

	fromAddWatermark := getValueByPath(fromObject, []string{"addWatermark"})
	if fromAddWatermark != nil {
		setValueByPath(parentObject, []string{"parameters", "addWatermark"}, fromAddWatermark)
	}

	fromEnhancePrompt := getValueByPath(fromObject, []string{"enhancePrompt"})
	if fromEnhancePrompt != nil {
		setValueByPath(parentObject, []string{"parameters", "enhancePrompt"}, fromEnhancePrompt)
	}

	return toObject, nil
}

func generateImagesParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromPrompt := getValueByPath(fromObject, []string{"prompt"})
	if fromPrompt != nil {
		setValueByPath(toObject, []string{"instances[0]", "prompt"}, fromPrompt)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = generateImagesConfigToMldev(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func generateImagesParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromPrompt := getValueByPath(fromObject, []string{"prompt"})
	if fromPrompt != nil {
		setValueByPath(toObject, []string{"instances[0]", "prompt"}, fromPrompt)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = generateImagesConfigToVertex(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func imageToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"gcsUri"}) != nil {
		return nil, fmt.Errorf("gcsUri parameter is not supported in Gemini API")
	}

	fromImageBytes := getValueByPath(fromObject, []string{"imageBytes"})
	if fromImageBytes != nil {
		fromImageBytes, err = tBytes(ac, fromImageBytes)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"bytesBase64Encoded"}, fromImageBytes)
	}

	fromMimeType := getValueByPath(fromObject, []string{"mimeType"})
	if fromMimeType != nil {
		setValueByPath(toObject, []string{"mimeType"}, fromMimeType)
	}

	return toObject, nil
}

func imageToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromGcsUri := getValueByPath(fromObject, []string{"gcsUri"})
	if fromGcsUri != nil {
		setValueByPath(toObject, []string{"gcsUri"}, fromGcsUri)
	}

	fromImageBytes := getValueByPath(fromObject, []string{"imageBytes"})
	if fromImageBytes != nil {
		fromImageBytes, err = tBytes(ac, fromImageBytes)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"bytesBase64Encoded"}, fromImageBytes)
	}

	fromMimeType := getValueByPath(fromObject, []string{"mimeType"})
	if fromMimeType != nil {
		setValueByPath(toObject, []string{"mimeType"}, fromMimeType)
	}

	return toObject, nil
}

func maskReferenceConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"maskMode"}) != nil {
		return nil, fmt.Errorf("maskMode parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"segmentationClasses"}) != nil {
		return nil, fmt.Errorf("segmentationClasses parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"maskDilation"}) != nil {
		return nil, fmt.Errorf("maskDilation parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func maskReferenceConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromMaskMode := getValueByPath(fromObject, []string{"maskMode"})
	if fromMaskMode != nil {
		setValueByPath(toObject, []string{"maskMode"}, fromMaskMode)
	}

	fromSegmentationClasses := getValueByPath(fromObject, []string{"segmentationClasses"})
	if fromSegmentationClasses != nil {
		setValueByPath(toObject, []string{"maskClasses"}, fromSegmentationClasses)
	}

	fromMaskDilation := getValueByPath(fromObject, []string{"maskDilation"})
	if fromMaskDilation != nil {
		setValueByPath(toObject, []string{"dilation"}, fromMaskDilation)
	}

	return toObject, nil
}

func controlReferenceConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"controlType"}) != nil {
		return nil, fmt.Errorf("controlType parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"enableControlImageComputation"}) != nil {
		return nil, fmt.Errorf("enableControlImageComputation parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func controlReferenceConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromControlType := getValueByPath(fromObject, []string{"controlType"})
	if fromControlType != nil {
		setValueByPath(toObject, []string{"controlType"}, fromControlType)
	}

	fromEnableControlImageComputation := getValueByPath(fromObject, []string{"enableControlImageComputation"})
	if fromEnableControlImageComputation != nil {
		setValueByPath(toObject, []string{"computeControl"}, fromEnableControlImageComputation)
	}

	return toObject, nil
}

func styleReferenceConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"styleDescription"}) != nil {
		return nil, fmt.Errorf("styleDescription parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func styleReferenceConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromStyleDescription := getValueByPath(fromObject, []string{"styleDescription"})
	if fromStyleDescription != nil {
		setValueByPath(toObject, []string{"styleDescription"}, fromStyleDescription)
	}

	return toObject, nil
}

func subjectReferenceConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"subjectType"}) != nil {
		return nil, fmt.Errorf("subjectType parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"subjectDescription"}) != nil {
		return nil, fmt.Errorf("subjectDescription parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func subjectReferenceConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromSubjectType := getValueByPath(fromObject, []string{"subjectType"})
	if fromSubjectType != nil {
		setValueByPath(toObject, []string{"subjectType"}, fromSubjectType)
	}

	fromSubjectDescription := getValueByPath(fromObject, []string{"subjectDescription"})
	if fromSubjectDescription != nil {
		setValueByPath(toObject, []string{"subjectDescription"}, fromSubjectDescription)
	}

	return toObject, nil
}

func referenceImageAPIToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)
	if getValueByPath(fromObject, []string{"referenceImage"}) != nil {
		return nil, fmt.Errorf("referenceImage parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"referenceId"}) != nil {
		return nil, fmt.Errorf("referenceId parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"referenceType"}) != nil {
		return nil, fmt.Errorf("referenceType parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"maskImageConfig"}) != nil {
		return nil, fmt.Errorf("maskImageConfig parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"controlImageConfig"}) != nil {
		return nil, fmt.Errorf("controlImageConfig parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"styleImageConfig"}) != nil {
		return nil, fmt.Errorf("styleImageConfig parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"subjectImageConfig"}) != nil {
		return nil, fmt.Errorf("subjectImageConfig parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func referenceImageAPIToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromReferenceImage := getValueByPath(fromObject, []string{"referenceImage"})
	if fromReferenceImage != nil {
		fromReferenceImage, err = imageToVertex(ac, fromReferenceImage.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"referenceImage"}, fromReferenceImage)
	}

	fromReferenceId := getValueByPath(fromObject, []string{"referenceId"})
	if fromReferenceId != nil {
		setValueByPath(toObject, []string{"referenceId"}, fromReferenceId)
	}

	fromReferenceType := getValueByPath(fromObject, []string{"referenceType"})
	if fromReferenceType != nil {
		setValueByPath(toObject, []string{"referenceType"}, fromReferenceType)
	}

	fromMaskImageConfig := getValueByPath(fromObject, []string{"maskImageConfig"})
	if fromMaskImageConfig != nil {
		fromMaskImageConfig, err = maskReferenceConfigToVertex(ac, fromMaskImageConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"maskImageConfig"}, fromMaskImageConfig)
	}

	fromControlImageConfig := getValueByPath(fromObject, []string{"controlImageConfig"})
	if fromControlImageConfig != nil {
		fromControlImageConfig, err = controlReferenceConfigToVertex(ac, fromControlImageConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"controlImageConfig"}, fromControlImageConfig)
	}

	fromStyleImageConfig := getValueByPath(fromObject, []string{"styleImageConfig"})
	if fromStyleImageConfig != nil {
		fromStyleImageConfig, err = styleReferenceConfigToVertex(ac, fromStyleImageConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"styleImageConfig"}, fromStyleImageConfig)
	}

	fromSubjectImageConfig := getValueByPath(fromObject, []string{"subjectImageConfig"})
	if fromSubjectImageConfig != nil {
		fromSubjectImageConfig, err = subjectReferenceConfigToVertex(ac, fromSubjectImageConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"subjectImageConfig"}, fromSubjectImageConfig)
	}

	return toObject, nil
}

func editImageConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	if getValueByPath(fromObject, []string{"outputGcsUri"}) != nil {
		return nil, fmt.Errorf("outputGcsUri parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"negativePrompt"}) != nil {
		return nil, fmt.Errorf("negativePrompt parameter is not supported in Gemini API")
	}

	fromNumberOfImages := getValueByPath(fromObject, []string{"numberOfImages"})
	if fromNumberOfImages != nil {
		setValueByPath(parentObject, []string{"parameters", "sampleCount"}, fromNumberOfImages)
	}

	fromAspectRatio := getValueByPath(fromObject, []string{"aspectRatio"})
	if fromAspectRatio != nil {
		setValueByPath(parentObject, []string{"parameters", "aspectRatio"}, fromAspectRatio)
	}

	fromGuidanceScale := getValueByPath(fromObject, []string{"guidanceScale"})
	if fromGuidanceScale != nil {
		setValueByPath(parentObject, []string{"parameters", "guidanceScale"}, fromGuidanceScale)
	}

	if getValueByPath(fromObject, []string{"seed"}) != nil {
		return nil, fmt.Errorf("seed parameter is not supported in Gemini API")
	}

	fromSafetyFilterLevel := getValueByPath(fromObject, []string{"safetyFilterLevel"})
	if fromSafetyFilterLevel != nil {
		setValueByPath(parentObject, []string{"parameters", "safetySetting"}, fromSafetyFilterLevel)
	}

	fromPersonGeneration := getValueByPath(fromObject, []string{"personGeneration"})
	if fromPersonGeneration != nil {
		setValueByPath(parentObject, []string{"parameters", "personGeneration"}, fromPersonGeneration)
	}

	fromIncludeSafetyAttributes := getValueByPath(fromObject, []string{"includeSafetyAttributes"})
	if fromIncludeSafetyAttributes != nil {
		setValueByPath(parentObject, []string{"parameters", "includeSafetyAttributes"}, fromIncludeSafetyAttributes)
	}

	fromIncludeRaiReason := getValueByPath(fromObject, []string{"includeRaiReason"})
	if fromIncludeRaiReason != nil {
		setValueByPath(parentObject, []string{"parameters", "includeRaiReason"}, fromIncludeRaiReason)
	}

	fromLanguage := getValueByPath(fromObject, []string{"language"})
	if fromLanguage != nil {
		setValueByPath(parentObject, []string{"parameters", "language"}, fromLanguage)
	}

	fromOutputMimeType := getValueByPath(fromObject, []string{"outputMimeType"})
	if fromOutputMimeType != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "mimeType"}, fromOutputMimeType)
	}

	fromOutputCompressionQuality := getValueByPath(fromObject, []string{"outputCompressionQuality"})
	if fromOutputCompressionQuality != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "compressionQuality"}, fromOutputCompressionQuality)
	}

	fromEditMode := getValueByPath(fromObject, []string{"editMode"})
	if fromEditMode != nil {
		setValueByPath(parentObject, []string{"parameters", "editMode"}, fromEditMode)
	}

	if getValueByPath(fromObject, []string{"baseSteps"}) != nil {
		return nil, fmt.Errorf("baseSteps parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func editImageConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromOutputGcsUri := getValueByPath(fromObject, []string{"outputGcsUri"})
	if fromOutputGcsUri != nil {
		setValueByPath(parentObject, []string{"parameters", "storageUri"}, fromOutputGcsUri)
	}

	fromNegativePrompt := getValueByPath(fromObject, []string{"negativePrompt"})
	if fromNegativePrompt != nil {
		setValueByPath(parentObject, []string{"parameters", "negativePrompt"}, fromNegativePrompt)
	}

	fromNumberOfImages := getValueByPath(fromObject, []string{"numberOfImages"})
	if fromNumberOfImages != nil {
		setValueByPath(parentObject, []string{"parameters", "sampleCount"}, fromNumberOfImages)
	}

	fromAspectRatio := getValueByPath(fromObject, []string{"aspectRatio"})
	if fromAspectRatio != nil {
		setValueByPath(parentObject, []string{"parameters", "aspectRatio"}, fromAspectRatio)
	}

	fromGuidanceScale := getValueByPath(fromObject, []string{"guidanceScale"})
	if fromGuidanceScale != nil {
		setValueByPath(parentObject, []string{"parameters", "guidanceScale"}, fromGuidanceScale)
	}

	fromSeed := getValueByPath(fromObject, []string{"seed"})
	if fromSeed != nil {
		setValueByPath(parentObject, []string{"parameters", "seed"}, fromSeed)
	}

	fromSafetyFilterLevel := getValueByPath(fromObject, []string{"safetyFilterLevel"})
	if fromSafetyFilterLevel != nil {
		setValueByPath(parentObject, []string{"parameters", "safetySetting"}, fromSafetyFilterLevel)
	}

	fromPersonGeneration := getValueByPath(fromObject, []string{"personGeneration"})
	if fromPersonGeneration != nil {
		setValueByPath(parentObject, []string{"parameters", "personGeneration"}, fromPersonGeneration)
	}

	fromIncludeSafetyAttributes := getValueByPath(fromObject, []string{"includeSafetyAttributes"})
	if fromIncludeSafetyAttributes != nil {
		setValueByPath(parentObject, []string{"parameters", "includeSafetyAttributes"}, fromIncludeSafetyAttributes)
	}

	fromIncludeRaiReason := getValueByPath(fromObject, []string{"includeRaiReason"})
	if fromIncludeRaiReason != nil {
		setValueByPath(parentObject, []string{"parameters", "includeRaiReason"}, fromIncludeRaiReason)
	}

	fromLanguage := getValueByPath(fromObject, []string{"language"})
	if fromLanguage != nil {
		setValueByPath(parentObject, []string{"parameters", "language"}, fromLanguage)
	}

	fromOutputMimeType := getValueByPath(fromObject, []string{"outputMimeType"})
	if fromOutputMimeType != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "mimeType"}, fromOutputMimeType)
	}

	fromOutputCompressionQuality := getValueByPath(fromObject, []string{"outputCompressionQuality"})
	if fromOutputCompressionQuality != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "compressionQuality"}, fromOutputCompressionQuality)
	}

	fromEditMode := getValueByPath(fromObject, []string{"editMode"})
	if fromEditMode != nil {
		setValueByPath(parentObject, []string{"parameters", "editMode"}, fromEditMode)
	}

	fromBaseSteps := getValueByPath(fromObject, []string{"baseSteps"})
	if fromBaseSteps != nil {
		setValueByPath(parentObject, []string{"parameters", "editConfig", "baseSteps"}, fromBaseSteps)
	}

	return toObject, nil
}

func editImageParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromPrompt := getValueByPath(fromObject, []string{"prompt"})
	if fromPrompt != nil {
		setValueByPath(toObject, []string{"instances[0]", "prompt"}, fromPrompt)
	}

	fromReferenceImages := getValueByPath(fromObject, []string{"referenceImages"})
	if fromReferenceImages != nil {
		fromReferenceImages, err = applyConverterToSlice(ac, fromReferenceImages.([]any), referenceImageAPIToMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"instances[0]", "referenceImages"}, fromReferenceImages)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = editImageConfigToMldev(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func editImageParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromPrompt := getValueByPath(fromObject, []string{"prompt"})
	if fromPrompt != nil {
		setValueByPath(toObject, []string{"instances[0]", "prompt"}, fromPrompt)
	}

	fromReferenceImages := getValueByPath(fromObject, []string{"referenceImages"})
	if fromReferenceImages != nil {
		fromReferenceImages, err = applyConverterToSlice(ac, fromReferenceImages.([]any), referenceImageAPIToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"instances[0]", "referenceImages"}, fromReferenceImages)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = editImageConfigToVertex(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func upscaleImageAPIConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromIncludeRaiReason := getValueByPath(fromObject, []string{"includeRaiReason"})
	if fromIncludeRaiReason != nil {
		setValueByPath(parentObject, []string{"parameters", "includeRaiReason"}, fromIncludeRaiReason)
	}

	fromOutputMimeType := getValueByPath(fromObject, []string{"outputMimeType"})
	if fromOutputMimeType != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "mimeType"}, fromOutputMimeType)
	}

	fromOutputCompressionQuality := getValueByPath(fromObject, []string{"outputCompressionQuality"})
	if fromOutputCompressionQuality != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "compressionQuality"}, fromOutputCompressionQuality)
	}

	fromNumberOfImages := getValueByPath(fromObject, []string{"numberOfImages"})
	if fromNumberOfImages != nil {
		setValueByPath(parentObject, []string{"parameters", "sampleCount"}, fromNumberOfImages)
	}

	fromMode := getValueByPath(fromObject, []string{"mode"})
	if fromMode != nil {
		setValueByPath(parentObject, []string{"parameters", "mode"}, fromMode)
	}

	return toObject, nil
}

func upscaleImageAPIConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromIncludeRaiReason := getValueByPath(fromObject, []string{"includeRaiReason"})
	if fromIncludeRaiReason != nil {
		setValueByPath(parentObject, []string{"parameters", "includeRaiReason"}, fromIncludeRaiReason)
	}

	fromOutputMimeType := getValueByPath(fromObject, []string{"outputMimeType"})
	if fromOutputMimeType != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "mimeType"}, fromOutputMimeType)
	}

	fromOutputCompressionQuality := getValueByPath(fromObject, []string{"outputCompressionQuality"})
	if fromOutputCompressionQuality != nil {
		setValueByPath(parentObject, []string{"parameters", "outputOptions", "compressionQuality"}, fromOutputCompressionQuality)
	}

	fromNumberOfImages := getValueByPath(fromObject, []string{"numberOfImages"})
	if fromNumberOfImages != nil {
		setValueByPath(parentObject, []string{"parameters", "sampleCount"}, fromNumberOfImages)
	}

	fromMode := getValueByPath(fromObject, []string{"mode"})
	if fromMode != nil {
		setValueByPath(parentObject, []string{"parameters", "mode"}, fromMode)
	}

	return toObject, nil
}

func upscaleImageAPIParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromImage := getValueByPath(fromObject, []string{"image"})
	if fromImage != nil {
		fromImage, err = imageToMldev(ac, fromImage.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"instances[0]", "image"}, fromImage)
	}

	fromUpscaleFactor := getValueByPath(fromObject, []string{"upscaleFactor"})
	if fromUpscaleFactor != nil {
		setValueByPath(toObject, []string{"parameters", "upscaleConfig", "upscaleFactor"}, fromUpscaleFactor)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = upscaleImageAPIConfigToMldev(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func upscaleImageAPIParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromImage := getValueByPath(fromObject, []string{"image"})
	if fromImage != nil {
		fromImage, err = imageToVertex(ac, fromImage.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"instances[0]", "image"}, fromImage)
	}

	fromUpscaleFactor := getValueByPath(fromObject, []string{"upscaleFactor"})
	if fromUpscaleFactor != nil {
		setValueByPath(toObject, []string{"parameters", "upscaleConfig", "upscaleFactor"}, fromUpscaleFactor)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = upscaleImageAPIConfigToVertex(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func getModelParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "name"}, fromModel)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func getModelParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "name"}, fromModel)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func listModelsConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromPageSize := getValueByPath(fromObject, []string{"pageSize"})
	if fromPageSize != nil {
		setValueByPath(parentObject, []string{"_query", "pageSize"}, fromPageSize)
	}

	fromPageToken := getValueByPath(fromObject, []string{"pageToken"})
	if fromPageToken != nil {
		setValueByPath(parentObject, []string{"_query", "pageToken"}, fromPageToken)
	}

	fromFilter := getValueByPath(fromObject, []string{"filter"})
	if fromFilter != nil {
		setValueByPath(parentObject, []string{"_query", "filter"}, fromFilter)
	}

	fromQueryBase := getValueByPath(fromObject, []string{"queryBase"})
	if fromQueryBase != nil {
		fromQueryBase, err = tModelsURL(ac, fromQueryBase)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"_url", "modelsUrl"}, fromQueryBase)
	}

	return toObject, nil
}

func listModelsConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromPageSize := getValueByPath(fromObject, []string{"pageSize"})
	if fromPageSize != nil {
		setValueByPath(parentObject, []string{"_query", "pageSize"}, fromPageSize)
	}

	fromPageToken := getValueByPath(fromObject, []string{"pageToken"})
	if fromPageToken != nil {
		setValueByPath(parentObject, []string{"_query", "pageToken"}, fromPageToken)
	}

	fromFilter := getValueByPath(fromObject, []string{"filter"})
	if fromFilter != nil {
		setValueByPath(parentObject, []string{"_query", "filter"}, fromFilter)
	}

	fromQueryBase := getValueByPath(fromObject, []string{"queryBase"})
	if fromQueryBase != nil {
		fromQueryBase, err = tModelsURL(ac, fromQueryBase)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"_url", "modelsUrl"}, fromQueryBase)
	}

	return toObject, nil
}

func listModelsParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = listModelsConfigToMldev(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func listModelsParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = listModelsConfigToVertex(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func updateModelConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromDisplayName := getValueByPath(fromObject, []string{"displayName"})
	if fromDisplayName != nil {
		setValueByPath(parentObject, []string{"displayName"}, fromDisplayName)
	}

	fromDescription := getValueByPath(fromObject, []string{"description"})
	if fromDescription != nil {
		setValueByPath(parentObject, []string{"description"}, fromDescription)
	}

	return toObject, nil
}

func updateModelConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromDisplayName := getValueByPath(fromObject, []string{"displayName"})
	if fromDisplayName != nil {
		setValueByPath(parentObject, []string{"displayName"}, fromDisplayName)
	}

	fromDescription := getValueByPath(fromObject, []string{"description"})
	if fromDescription != nil {
		setValueByPath(parentObject, []string{"description"}, fromDescription)
	}

	return toObject, nil
}

func updateModelParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "name"}, fromModel)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = updateModelConfigToMldev(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func updateModelParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = updateModelConfigToVertex(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func deleteModelParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "name"}, fromModel)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func deleteModelParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "name"}, fromModel)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func countTokensConfigToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	if getValueByPath(fromObject, []string{"systemInstruction"}) != nil {
		return nil, fmt.Errorf("systemInstruction parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"tools"}) != nil {
		return nil, fmt.Errorf("tools parameter is not supported in Gemini API")
	}

	if getValueByPath(fromObject, []string{"generationConfig"}) != nil {
		return nil, fmt.Errorf("generationConfig parameter is not supported in Gemini API")
	}

	return toObject, nil
}

func countTokensConfigToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromSystemInstruction := getValueByPath(fromObject, []string{"systemInstruction"})
	if fromSystemInstruction != nil {
		fromSystemInstruction, err = tContent(ac, fromSystemInstruction)
		if err != nil {
			return nil, err
		}

		fromSystemInstruction, err = contentToVertex(ac, fromSystemInstruction.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"systemInstruction"}, fromSystemInstruction)
	}

	fromTools := getValueByPath(fromObject, []string{"tools"})
	if fromTools != nil {
		fromTools, err = applyConverterToSlice(ac, fromTools.([]any), toolToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(parentObject, []string{"tools"}, fromTools)
	}

	fromGenerationConfig := getValueByPath(fromObject, []string{"generationConfig"})
	if fromGenerationConfig != nil {
		setValueByPath(parentObject, []string{"generationConfig"}, fromGenerationConfig)
	}

	return toObject, nil
}

func countTokensParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromContents := getValueByPath(fromObject, []string{"contents"})
	if fromContents != nil {
		fromContents, err = tContents(ac, fromContents)
		if err != nil {
			return nil, err
		}

		fromContents, err = applyConverterToSlice(ac, fromContents.([]any), contentToMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"contents"}, fromContents)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = countTokensConfigToMldev(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func countTokensParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromContents := getValueByPath(fromObject, []string{"contents"})
	if fromContents != nil {
		fromContents, err = tContents(ac, fromContents)
		if err != nil {
			return nil, err
		}

		fromContents, err = applyConverterToSlice(ac, fromContents.([]any), contentToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"contents"}, fromContents)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		fromConfig, err = countTokensConfigToVertex(ac, fromConfig.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func computeTokensParametersToMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	if getValueByPath(fromObject, []string{"contents"}) != nil {
		return nil, fmt.Errorf("contents parameter is not supported in Gemini API")
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func computeTokensParametersToVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromModel := getValueByPath(fromObject, []string{"model"})
	if fromModel != nil {
		fromModel, err = tModel(ac, fromModel)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"_url", "model"}, fromModel)
	}

	fromContents := getValueByPath(fromObject, []string{"contents"})
	if fromContents != nil {
		fromContents, err = tContents(ac, fromContents)
		if err != nil {
			return nil, err
		}

		fromContents, err = applyConverterToSlice(ac, fromContents.([]any), contentToVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"contents"}, fromContents)
	}

	fromConfig := getValueByPath(fromObject, []string{"config"})
	if fromConfig != nil {
		setValueByPath(toObject, []string{"config"}, fromConfig)
	}

	return toObject, nil
}

func partFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromThought := getValueByPath(fromObject, []string{"thought"})
	if fromThought != nil {
		setValueByPath(toObject, []string{"thought"}, fromThought)
	}

	fromCodeExecutionResult := getValueByPath(fromObject, []string{"codeExecutionResult"})
	if fromCodeExecutionResult != nil {
		setValueByPath(toObject, []string{"codeExecutionResult"}, fromCodeExecutionResult)
	}

	fromExecutableCode := getValueByPath(fromObject, []string{"executableCode"})
	if fromExecutableCode != nil {
		setValueByPath(toObject, []string{"executableCode"}, fromExecutableCode)
	}

	fromFileData := getValueByPath(fromObject, []string{"fileData"})
	if fromFileData != nil {
		setValueByPath(toObject, []string{"fileData"}, fromFileData)
	}

	fromFunctionCall := getValueByPath(fromObject, []string{"functionCall"})
	if fromFunctionCall != nil {
		setValueByPath(toObject, []string{"functionCall"}, fromFunctionCall)
	}

	fromFunctionResponse := getValueByPath(fromObject, []string{"functionResponse"})
	if fromFunctionResponse != nil {
		setValueByPath(toObject, []string{"functionResponse"}, fromFunctionResponse)
	}

	fromInlineData := getValueByPath(fromObject, []string{"inlineData"})
	if fromInlineData != nil {
		setValueByPath(toObject, []string{"inlineData"}, fromInlineData)
	}

	fromText := getValueByPath(fromObject, []string{"text"})
	if fromText != nil {
		setValueByPath(toObject, []string{"text"}, fromText)
	}

	return toObject, nil
}

func partFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromVideoMetadata := getValueByPath(fromObject, []string{"videoMetadata"})
	if fromVideoMetadata != nil {
		setValueByPath(toObject, []string{"videoMetadata"}, fromVideoMetadata)
	}

	fromThought := getValueByPath(fromObject, []string{"thought"})
	if fromThought != nil {
		setValueByPath(toObject, []string{"thought"}, fromThought)
	}

	fromCodeExecutionResult := getValueByPath(fromObject, []string{"codeExecutionResult"})
	if fromCodeExecutionResult != nil {
		setValueByPath(toObject, []string{"codeExecutionResult"}, fromCodeExecutionResult)
	}

	fromExecutableCode := getValueByPath(fromObject, []string{"executableCode"})
	if fromExecutableCode != nil {
		setValueByPath(toObject, []string{"executableCode"}, fromExecutableCode)
	}

	fromFileData := getValueByPath(fromObject, []string{"fileData"})
	if fromFileData != nil {
		setValueByPath(toObject, []string{"fileData"}, fromFileData)
	}

	fromFunctionCall := getValueByPath(fromObject, []string{"functionCall"})
	if fromFunctionCall != nil {
		setValueByPath(toObject, []string{"functionCall"}, fromFunctionCall)
	}

	fromFunctionResponse := getValueByPath(fromObject, []string{"functionResponse"})
	if fromFunctionResponse != nil {
		setValueByPath(toObject, []string{"functionResponse"}, fromFunctionResponse)
	}

	fromInlineData := getValueByPath(fromObject, []string{"inlineData"})
	if fromInlineData != nil {
		setValueByPath(toObject, []string{"inlineData"}, fromInlineData)
	}

	fromText := getValueByPath(fromObject, []string{"text"})
	if fromText != nil {
		setValueByPath(toObject, []string{"text"}, fromText)
	}

	return toObject, nil
}

func contentFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromParts := getValueByPath(fromObject, []string{"parts"})
	if fromParts != nil {
		fromParts, err = applyConverterToSlice(ac, fromParts.([]any), partFromMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"parts"}, fromParts)
	}

	fromRole := getValueByPath(fromObject, []string{"role"})
	if fromRole != nil {
		setValueByPath(toObject, []string{"role"}, fromRole)
	}

	return toObject, nil
}

func contentFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromParts := getValueByPath(fromObject, []string{"parts"})
	if fromParts != nil {
		fromParts, err = applyConverterToSlice(ac, fromParts.([]any), partFromVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"parts"}, fromParts)
	}

	fromRole := getValueByPath(fromObject, []string{"role"})
	if fromRole != nil {
		setValueByPath(toObject, []string{"role"}, fromRole)
	}

	return toObject, nil
}

func citationMetadataFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromCitations := getValueByPath(fromObject, []string{"citationSources"})
	if fromCitations != nil {
		setValueByPath(toObject, []string{"citations"}, fromCitations)
	}

	return toObject, nil
}

func citationMetadataFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromCitations := getValueByPath(fromObject, []string{"citations"})
	if fromCitations != nil {
		setValueByPath(toObject, []string{"citations"}, fromCitations)
	}

	return toObject, nil
}

func candidateFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromContent := getValueByPath(fromObject, []string{"content"})
	if fromContent != nil {
		fromContent, err = contentFromMldev(ac, fromContent.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"content"}, fromContent)
	}

	fromCitationMetadata := getValueByPath(fromObject, []string{"citationMetadata"})
	if fromCitationMetadata != nil {
		fromCitationMetadata, err = citationMetadataFromMldev(ac, fromCitationMetadata.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"citationMetadata"}, fromCitationMetadata)
	}

	fromTokenCount := getValueByPath(fromObject, []string{"tokenCount"})
	if fromTokenCount != nil {
		setValueByPath(toObject, []string{"tokenCount"}, fromTokenCount)
	}

	fromAvgLogprobs := getValueByPath(fromObject, []string{"avgLogprobs"})
	if fromAvgLogprobs != nil {
		setValueByPath(toObject, []string{"avgLogprobs"}, fromAvgLogprobs)
	}

	fromFinishReason := getValueByPath(fromObject, []string{"finishReason"})
	if fromFinishReason != nil {
		setValueByPath(toObject, []string{"finishReason"}, fromFinishReason)
	}

	fromGroundingMetadata := getValueByPath(fromObject, []string{"groundingMetadata"})
	if fromGroundingMetadata != nil {
		setValueByPath(toObject, []string{"groundingMetadata"}, fromGroundingMetadata)
	}

	fromIndex := getValueByPath(fromObject, []string{"index"})
	if fromIndex != nil {
		setValueByPath(toObject, []string{"index"}, fromIndex)
	}

	fromLogprobsResult := getValueByPath(fromObject, []string{"logprobsResult"})
	if fromLogprobsResult != nil {
		setValueByPath(toObject, []string{"logprobsResult"}, fromLogprobsResult)
	}

	fromSafetyRatings := getValueByPath(fromObject, []string{"safetyRatings"})
	if fromSafetyRatings != nil {
		setValueByPath(toObject, []string{"safetyRatings"}, fromSafetyRatings)
	}

	return toObject, nil
}

func candidateFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromContent := getValueByPath(fromObject, []string{"content"})
	if fromContent != nil {
		fromContent, err = contentFromVertex(ac, fromContent.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"content"}, fromContent)
	}

	fromCitationMetadata := getValueByPath(fromObject, []string{"citationMetadata"})
	if fromCitationMetadata != nil {
		fromCitationMetadata, err = citationMetadataFromVertex(ac, fromCitationMetadata.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"citationMetadata"}, fromCitationMetadata)
	}

	fromFinishMessage := getValueByPath(fromObject, []string{"finishMessage"})
	if fromFinishMessage != nil {
		setValueByPath(toObject, []string{"finishMessage"}, fromFinishMessage)
	}

	fromAvgLogprobs := getValueByPath(fromObject, []string{"avgLogprobs"})
	if fromAvgLogprobs != nil {
		setValueByPath(toObject, []string{"avgLogprobs"}, fromAvgLogprobs)
	}

	fromFinishReason := getValueByPath(fromObject, []string{"finishReason"})
	if fromFinishReason != nil {
		setValueByPath(toObject, []string{"finishReason"}, fromFinishReason)
	}

	fromGroundingMetadata := getValueByPath(fromObject, []string{"groundingMetadata"})
	if fromGroundingMetadata != nil {
		setValueByPath(toObject, []string{"groundingMetadata"}, fromGroundingMetadata)
	}

	fromIndex := getValueByPath(fromObject, []string{"index"})
	if fromIndex != nil {
		setValueByPath(toObject, []string{"index"}, fromIndex)
	}

	fromLogprobsResult := getValueByPath(fromObject, []string{"logprobsResult"})
	if fromLogprobsResult != nil {
		setValueByPath(toObject, []string{"logprobsResult"}, fromLogprobsResult)
	}

	fromSafetyRatings := getValueByPath(fromObject, []string{"safetyRatings"})
	if fromSafetyRatings != nil {
		setValueByPath(toObject, []string{"safetyRatings"}, fromSafetyRatings)
	}

	return toObject, nil
}

func generateContentResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromCandidates := getValueByPath(fromObject, []string{"candidates"})
	if fromCandidates != nil {
		fromCandidates, err = applyConverterToSlice(ac, fromCandidates.([]any), candidateFromMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"candidates"}, fromCandidates)
	}

	fromModelVersion := getValueByPath(fromObject, []string{"modelVersion"})
	if fromModelVersion != nil {
		setValueByPath(toObject, []string{"modelVersion"}, fromModelVersion)
	}

	fromPromptFeedback := getValueByPath(fromObject, []string{"promptFeedback"})
	if fromPromptFeedback != nil {
		setValueByPath(toObject, []string{"promptFeedback"}, fromPromptFeedback)
	}

	fromUsageMetadata := getValueByPath(fromObject, []string{"usageMetadata"})
	if fromUsageMetadata != nil {
		setValueByPath(toObject, []string{"usageMetadata"}, fromUsageMetadata)
	}

	return toObject, nil
}

func generateContentResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromCandidates := getValueByPath(fromObject, []string{"candidates"})
	if fromCandidates != nil {
		fromCandidates, err = applyConverterToSlice(ac, fromCandidates.([]any), candidateFromVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"candidates"}, fromCandidates)
	}

	fromCreateTime := getValueByPath(fromObject, []string{"createTime"})
	if fromCreateTime != nil {
		setValueByPath(toObject, []string{"createTime"}, fromCreateTime)
	}

	fromResponseId := getValueByPath(fromObject, []string{"responseId"})
	if fromResponseId != nil {
		setValueByPath(toObject, []string{"responseId"}, fromResponseId)
	}

	fromModelVersion := getValueByPath(fromObject, []string{"modelVersion"})
	if fromModelVersion != nil {
		setValueByPath(toObject, []string{"modelVersion"}, fromModelVersion)
	}

	fromPromptFeedback := getValueByPath(fromObject, []string{"promptFeedback"})
	if fromPromptFeedback != nil {
		setValueByPath(toObject, []string{"promptFeedback"}, fromPromptFeedback)
	}

	fromUsageMetadata := getValueByPath(fromObject, []string{"usageMetadata"})
	if fromUsageMetadata != nil {
		setValueByPath(toObject, []string{"usageMetadata"}, fromUsageMetadata)
	}

	return toObject, nil
}

func contentEmbeddingStatisticsFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	return toObject, nil
}

func contentEmbeddingStatisticsFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromTruncated := getValueByPath(fromObject, []string{"truncated"})
	if fromTruncated != nil {
		setValueByPath(toObject, []string{"truncated"}, fromTruncated)
	}

	fromTokenCount := getValueByPath(fromObject, []string{"tokenCount"})
	if fromTokenCount != nil {
		setValueByPath(toObject, []string{"tokenCount"}, fromTokenCount)
	}

	return toObject, nil
}

func contentEmbeddingFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromValues := getValueByPath(fromObject, []string{"values"})
	if fromValues != nil {
		setValueByPath(toObject, []string{"values"}, fromValues)
	}

	return toObject, nil
}

func contentEmbeddingFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromValues := getValueByPath(fromObject, []string{"values"})
	if fromValues != nil {
		setValueByPath(toObject, []string{"values"}, fromValues)
	}

	fromStatistics := getValueByPath(fromObject, []string{"statistics"})
	if fromStatistics != nil {
		fromStatistics, err = contentEmbeddingStatisticsFromVertex(ac, fromStatistics.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"statistics"}, fromStatistics)
	}

	return toObject, nil
}

func embedContentMetadataFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	return toObject, nil
}

func embedContentMetadataFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromBillableCharacterCount := getValueByPath(fromObject, []string{"billableCharacterCount"})
	if fromBillableCharacterCount != nil {
		setValueByPath(toObject, []string{"billableCharacterCount"}, fromBillableCharacterCount)
	}

	return toObject, nil
}

func embedContentResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromEmbeddings := getValueByPath(fromObject, []string{"embeddings"})
	if fromEmbeddings != nil {
		fromEmbeddings, err = applyConverterToSlice(ac, fromEmbeddings.([]any), contentEmbeddingFromMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"embeddings"}, fromEmbeddings)
	}

	fromMetadata := getValueByPath(fromObject, []string{"metadata"})
	if fromMetadata != nil {
		fromMetadata, err = embedContentMetadataFromMldev(ac, fromMetadata.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"metadata"}, fromMetadata)
	}

	return toObject, nil
}

func embedContentResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromEmbeddings := getValueByPath(fromObject, []string{"predictions[]", "embeddings"})
	if fromEmbeddings != nil {
		fromEmbeddings, err = applyConverterToSlice(ac, fromEmbeddings.([]any), contentEmbeddingFromVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"embeddings"}, fromEmbeddings)
	}

	fromMetadata := getValueByPath(fromObject, []string{"metadata"})
	if fromMetadata != nil {
		fromMetadata, err = embedContentMetadataFromVertex(ac, fromMetadata.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"metadata"}, fromMetadata)
	}

	return toObject, nil
}

func imageFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromImageBytes := getValueByPath(fromObject, []string{"bytesBase64Encoded"})
	if fromImageBytes != nil {
		fromImageBytes, err = tBytes(ac, fromImageBytes)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"imageBytes"}, fromImageBytes)
	}

	fromMimeType := getValueByPath(fromObject, []string{"mimeType"})
	if fromMimeType != nil {
		setValueByPath(toObject, []string{"mimeType"}, fromMimeType)
	}

	return toObject, nil
}

func imageFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromGcsUri := getValueByPath(fromObject, []string{"gcsUri"})
	if fromGcsUri != nil {
		setValueByPath(toObject, []string{"gcsUri"}, fromGcsUri)
	}

	fromImageBytes := getValueByPath(fromObject, []string{"bytesBase64Encoded"})
	if fromImageBytes != nil {
		fromImageBytes, err = tBytes(ac, fromImageBytes)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"imageBytes"}, fromImageBytes)
	}

	fromMimeType := getValueByPath(fromObject, []string{"mimeType"})
	if fromMimeType != nil {
		setValueByPath(toObject, []string{"mimeType"}, fromMimeType)
	}

	return toObject, nil
}

func safetyAttributesFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromCategories := getValueByPath(fromObject, []string{"safetyAttributes", "categories"})
	if fromCategories != nil {
		setValueByPath(toObject, []string{"categories"}, fromCategories)
	}

	fromScores := getValueByPath(fromObject, []string{"safetyAttributes", "scores"})
	if fromScores != nil {
		setValueByPath(toObject, []string{"scores"}, fromScores)
	}

	return toObject, nil
}

func safetyAttributesFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromCategories := getValueByPath(fromObject, []string{"safetyAttributes", "categories"})
	if fromCategories != nil {
		setValueByPath(toObject, []string{"categories"}, fromCategories)
	}

	fromScores := getValueByPath(fromObject, []string{"safetyAttributes", "scores"})
	if fromScores != nil {
		setValueByPath(toObject, []string{"scores"}, fromScores)
	}

	return toObject, nil
}

func generatedImageFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromImage := getValueByPath(fromObject, []string{"_self"})
	if fromImage != nil {
		fromImage, err = imageFromMldev(ac, fromImage.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"image"}, fromImage)
	}

	fromRaiFilteredReason := getValueByPath(fromObject, []string{"raiFilteredReason"})
	if fromRaiFilteredReason != nil {
		setValueByPath(toObject, []string{"raiFilteredReason"}, fromRaiFilteredReason)
	}

	fromSafetyAttributes := getValueByPath(fromObject, []string{"_self"})
	if fromSafetyAttributes != nil {
		fromSafetyAttributes, err = safetyAttributesFromMldev(ac, fromSafetyAttributes.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"safetyAttributes"}, fromSafetyAttributes)
	}

	return toObject, nil
}

func generatedImageFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromImage := getValueByPath(fromObject, []string{"_self"})
	if fromImage != nil {
		fromImage, err = imageFromVertex(ac, fromImage.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"image"}, fromImage)
	}

	fromRaiFilteredReason := getValueByPath(fromObject, []string{"raiFilteredReason"})
	if fromRaiFilteredReason != nil {
		setValueByPath(toObject, []string{"raiFilteredReason"}, fromRaiFilteredReason)
	}

	fromSafetyAttributes := getValueByPath(fromObject, []string{"_self"})
	if fromSafetyAttributes != nil {
		fromSafetyAttributes, err = safetyAttributesFromVertex(ac, fromSafetyAttributes.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"safetyAttributes"}, fromSafetyAttributes)
	}

	fromEnhancedPrompt := getValueByPath(fromObject, []string{"prompt"})
	if fromEnhancedPrompt != nil {
		setValueByPath(toObject, []string{"enhancedPrompt"}, fromEnhancedPrompt)
	}

	return toObject, nil
}

func generateImagesResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromGeneratedImages := getValueByPath(fromObject, []string{"predictions"})
	if fromGeneratedImages != nil {
		fromGeneratedImages, err = applyConverterToSlice(ac, fromGeneratedImages.([]any), generatedImageFromMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"generatedImages"}, fromGeneratedImages)
	}

	return toObject, nil
}

func generateImagesResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromGeneratedImages := getValueByPath(fromObject, []string{"predictions"})
	if fromGeneratedImages != nil {
		fromGeneratedImages, err = applyConverterToSlice(ac, fromGeneratedImages.([]any), generatedImageFromVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"generatedImages"}, fromGeneratedImages)
	}

	return toObject, nil
}

func editImageResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromGeneratedImages := getValueByPath(fromObject, []string{"predictions"})
	if fromGeneratedImages != nil {
		fromGeneratedImages, err = applyConverterToSlice(ac, fromGeneratedImages.([]any), generatedImageFromMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"generatedImages"}, fromGeneratedImages)
	}

	return toObject, nil
}

func editImageResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromGeneratedImages := getValueByPath(fromObject, []string{"predictions"})
	if fromGeneratedImages != nil {
		fromGeneratedImages, err = applyConverterToSlice(ac, fromGeneratedImages.([]any), generatedImageFromVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"generatedImages"}, fromGeneratedImages)
	}

	return toObject, nil
}

func upscaleImageResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromGeneratedImages := getValueByPath(fromObject, []string{"predictions"})
	if fromGeneratedImages != nil {
		fromGeneratedImages, err = applyConverterToSlice(ac, fromGeneratedImages.([]any), generatedImageFromMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"generatedImages"}, fromGeneratedImages)
	}

	return toObject, nil
}

func upscaleImageResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromGeneratedImages := getValueByPath(fromObject, []string{"predictions"})
	if fromGeneratedImages != nil {
		fromGeneratedImages, err = applyConverterToSlice(ac, fromGeneratedImages.([]any), generatedImageFromVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"generatedImages"}, fromGeneratedImages)
	}

	return toObject, nil
}

func endpointFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	return toObject, nil
}

func endpointFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromName := getValueByPath(fromObject, []string{"endpoint"})
	if fromName != nil {
		setValueByPath(toObject, []string{"name"}, fromName)
	}

	fromDeployedModelId := getValueByPath(fromObject, []string{"deployedModelId"})
	if fromDeployedModelId != nil {
		setValueByPath(toObject, []string{"deployedModelId"}, fromDeployedModelId)
	}

	return toObject, nil
}

func tunedModelInfoFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromBaseModel := getValueByPath(fromObject, []string{"baseModel"})
	if fromBaseModel != nil {
		setValueByPath(toObject, []string{"baseModel"}, fromBaseModel)
	}

	fromCreateTime := getValueByPath(fromObject, []string{"createTime"})
	if fromCreateTime != nil {
		setValueByPath(toObject, []string{"createTime"}, fromCreateTime)
	}

	fromUpdateTime := getValueByPath(fromObject, []string{"updateTime"})
	if fromUpdateTime != nil {
		setValueByPath(toObject, []string{"updateTime"}, fromUpdateTime)
	}

	return toObject, nil
}

func tunedModelInfoFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromBaseModel := getValueByPath(fromObject, []string{"labels", "google-vertex-llm-tuning-base-model-id"})
	if fromBaseModel != nil {
		setValueByPath(toObject, []string{"baseModel"}, fromBaseModel)
	}

	fromCreateTime := getValueByPath(fromObject, []string{"createTime"})
	if fromCreateTime != nil {
		setValueByPath(toObject, []string{"createTime"}, fromCreateTime)
	}

	fromUpdateTime := getValueByPath(fromObject, []string{"updateTime"})
	if fromUpdateTime != nil {
		setValueByPath(toObject, []string{"updateTime"}, fromUpdateTime)
	}

	return toObject, nil
}

func modelFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromName := getValueByPath(fromObject, []string{"name"})
	if fromName != nil {
		setValueByPath(toObject, []string{"name"}, fromName)
	}

	fromDisplayName := getValueByPath(fromObject, []string{"displayName"})
	if fromDisplayName != nil {
		setValueByPath(toObject, []string{"displayName"}, fromDisplayName)
	}

	fromDescription := getValueByPath(fromObject, []string{"description"})
	if fromDescription != nil {
		setValueByPath(toObject, []string{"description"}, fromDescription)
	}

	fromVersion := getValueByPath(fromObject, []string{"version"})
	if fromVersion != nil {
		setValueByPath(toObject, []string{"version"}, fromVersion)
	}

	fromTunedModelInfo := getValueByPath(fromObject, []string{"_self"})
	if fromTunedModelInfo != nil {
		fromTunedModelInfo, err = tunedModelInfoFromMldev(ac, fromTunedModelInfo.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"tunedModelInfo"}, fromTunedModelInfo)
	}

	fromInputTokenLimit := getValueByPath(fromObject, []string{"inputTokenLimit"})
	if fromInputTokenLimit != nil {
		setValueByPath(toObject, []string{"inputTokenLimit"}, fromInputTokenLimit)
	}

	fromOutputTokenLimit := getValueByPath(fromObject, []string{"outputTokenLimit"})
	if fromOutputTokenLimit != nil {
		setValueByPath(toObject, []string{"outputTokenLimit"}, fromOutputTokenLimit)
	}

	fromSupportedActions := getValueByPath(fromObject, []string{"supportedGenerationMethods"})
	if fromSupportedActions != nil {
		setValueByPath(toObject, []string{"supportedActions"}, fromSupportedActions)
	}

	return toObject, nil
}

func modelFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromName := getValueByPath(fromObject, []string{"name"})
	if fromName != nil {
		setValueByPath(toObject, []string{"name"}, fromName)
	}

	fromDisplayName := getValueByPath(fromObject, []string{"displayName"})
	if fromDisplayName != nil {
		setValueByPath(toObject, []string{"displayName"}, fromDisplayName)
	}

	fromDescription := getValueByPath(fromObject, []string{"description"})
	if fromDescription != nil {
		setValueByPath(toObject, []string{"description"}, fromDescription)
	}

	fromVersion := getValueByPath(fromObject, []string{"versionId"})
	if fromVersion != nil {
		setValueByPath(toObject, []string{"version"}, fromVersion)
	}

	fromEndpoints := getValueByPath(fromObject, []string{"deployedModels"})
	if fromEndpoints != nil {
		fromEndpoints, err = applyConverterToSlice(ac, fromEndpoints.([]any), endpointFromVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"endpoints"}, fromEndpoints)
	}

	fromLabels := getValueByPath(fromObject, []string{"labels"})
	if fromLabels != nil {
		setValueByPath(toObject, []string{"labels"}, fromLabels)
	}

	fromTunedModelInfo := getValueByPath(fromObject, []string{"_self"})
	if fromTunedModelInfo != nil {
		fromTunedModelInfo, err = tunedModelInfoFromVertex(ac, fromTunedModelInfo.(map[string]any), toObject)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"tunedModelInfo"}, fromTunedModelInfo)
	}

	return toObject, nil
}

func listModelsResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromNextPageToken := getValueByPath(fromObject, []string{"nextPageToken"})
	if fromNextPageToken != nil {
		setValueByPath(toObject, []string{"nextPageToken"}, fromNextPageToken)
	}

	fromModels := getValueByPath(fromObject, []string{"_self"})
	if fromModels != nil {
		fromModels, err = tExtractModels(ac, fromModels)
		if err != nil {
			return nil, err
		}

		fromModels, err = applyConverterToSlice(ac, fromModels.([]any), modelFromMldev)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"models"}, fromModels)
	}

	return toObject, nil
}

func listModelsResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromNextPageToken := getValueByPath(fromObject, []string{"nextPageToken"})
	if fromNextPageToken != nil {
		setValueByPath(toObject, []string{"nextPageToken"}, fromNextPageToken)
	}

	fromModels := getValueByPath(fromObject, []string{"_self"})
	if fromModels != nil {
		fromModels, err = tExtractModels(ac, fromModels)
		if err != nil {
			return nil, err
		}

		fromModels, err = applyConverterToSlice(ac, fromModels.([]any), modelFromVertex)
		if err != nil {
			return nil, err
		}

		setValueByPath(toObject, []string{"models"}, fromModels)
	}

	return toObject, nil
}

func deleteModelResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	return toObject, nil
}

func deleteModelResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	return toObject, nil
}

func countTokensResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromTotalTokens := getValueByPath(fromObject, []string{"totalTokens"})
	if fromTotalTokens != nil {
		setValueByPath(toObject, []string{"totalTokens"}, fromTotalTokens)
	}

	fromCachedContentTokenCount := getValueByPath(fromObject, []string{"cachedContentTokenCount"})
	if fromCachedContentTokenCount != nil {
		setValueByPath(toObject, []string{"cachedContentTokenCount"}, fromCachedContentTokenCount)
	}

	return toObject, nil
}

func countTokensResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromTotalTokens := getValueByPath(fromObject, []string{"totalTokens"})
	if fromTotalTokens != nil {
		setValueByPath(toObject, []string{"totalTokens"}, fromTotalTokens)
	}

	return toObject, nil
}

func computeTokensResponseFromMldev(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromTokensInfo := getValueByPath(fromObject, []string{"tokensInfo"})
	if fromTokensInfo != nil {
		setValueByPath(toObject, []string{"tokensInfo"}, fromTokensInfo)
	}

	return toObject, nil
}

func computeTokensResponseFromVertex(ac *apiClient, fromObject map[string]any, parentObject map[string]any) (toObject map[string]any, err error) {
	toObject = make(map[string]any)

	fromTokensInfo := getValueByPath(fromObject, []string{"tokensInfo"})
	if fromTokensInfo != nil {
		setValueByPath(toObject, []string{"tokensInfo"}, fromTokensInfo)
	}

	return toObject, nil
}

type Models struct {
	apiClient *apiClient
}

func (m Models) generateContent(ctx context.Context, model string, contents []*Content, config *GenerateContentConfig) (*GenerateContentResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "contents": contents, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var response = new(GenerateContentResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = generateContentParametersToVertex
		fromConverter = generateContentResponseFromVertex
	} else {
		toConverter = generateContentParametersToMldev
		fromConverter = generateContentResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}:generateContent", urlParams)
	} else {
		path, err = formatMap("{model}:generateContent", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

// generateContentStream ...
func (m Models) generateContentStream(ctx context.Context, model string, contents []*Content, config *GenerateContentConfig) iter.Seq2[*GenerateContentResponse, error] {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "contents": contents, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var rs responseStream[GenerateContentResponse]
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = generateContentParametersToVertex
		fromConverter = generateContentResponseFromVertex
	} else {
		toConverter = generateContentParametersToMldev
		fromConverter = generateContentResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return yieldErrorAndEndIterator[GenerateContentResponse](err)
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}:streamGenerateContent?alt=sse", urlParams)
	} else {
		path, err = formatMap("{model}:streamGenerateContent?alt=sse", urlParams)
	}
	if err != nil {
		return yieldErrorAndEndIterator[GenerateContentResponse](fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err))
	}
	delete(body, "_url")
	delete(body, "config")
	err = sendStreamRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions, &rs)
	if err != nil {
		return yieldErrorAndEndIterator[GenerateContentResponse](err)
	}
	return iterateResponseStream(&rs, func(responseMap map[string]any) (*GenerateContentResponse, error) {
		responseMap, err := fromConverter(m.apiClient, responseMap, nil)
		if err != nil {
			return nil, err
		}
		var response = new(GenerateContentResponse)
		err = mapToStruct(responseMap, response)
		if err != nil {
			return nil, err
		}
		return response, nil
	})
}

func (m Models) EmbedContent(ctx context.Context, model string, contents []*Content, config *EmbedContentConfig) (*EmbedContentResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "contents": contents, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var response = new(EmbedContentResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = embedContentParametersToVertex
		fromConverter = embedContentResponseFromVertex
	} else {
		toConverter = embedContentParametersToMldev
		fromConverter = embedContentResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}:predict", urlParams)
	} else {
		path, err = formatMap("{model}:batchEmbedContents", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) GenerateImages(ctx context.Context, model string, prompt string, config *GenerateImagesConfig) (*GenerateImagesResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "prompt": prompt, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var response = new(GenerateImagesResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = generateImagesParametersToVertex
		fromConverter = generateImagesResponseFromVertex
	} else {
		toConverter = generateImagesParametersToMldev
		fromConverter = generateImagesResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}:predict", urlParams)
	} else {
		path, err = formatMap("{model}:predict", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) editImage(ctx context.Context, model string, prompt string, referenceImages []*referenceImageAPI, config *EditImageConfig) (*EditImageResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "prompt": prompt, "referenceImages": referenceImages, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}
	if m.apiClient.clientConfig.Backend == BackendGeminiAPI {
		return nil, fmt.Errorf("method EditImage is only supported in the Vertex AI client. You can choose to use Vertex AI by setting ClientConfig.Backend to BackendVertexAI.")
	}

	var response = new(EditImageResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = editImageParametersToVertex
		fromConverter = editImageResponseFromVertex
	} else {
		toConverter = editImageParametersToMldev
		fromConverter = editImageResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}:predict", urlParams)
	} else {
		path, err = formatMap("None", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) upscaleImage(ctx context.Context, model string, image *Image, upscaleFactor string, config *upscaleImageAPIConfig) (*UpscaleImageResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "image": image, "upscaleFactor": upscaleFactor, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}
	if m.apiClient.clientConfig.Backend == BackendGeminiAPI {
		return nil, fmt.Errorf("method UpscaleImage is only supported in the Vertex AI client. You can choose to use Vertex AI by setting ClientConfig.Backend to BackendVertexAI.")
	}

	var response = new(UpscaleImageResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = upscaleImageAPIParametersToVertex
		fromConverter = upscaleImageResponseFromVertex
	} else {
		toConverter = upscaleImageAPIParametersToMldev
		fromConverter = upscaleImageResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}:predict", urlParams)
	} else {
		path, err = formatMap("None", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) Get(ctx context.Context, model string, config *GetModelConfig) (*Model, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var response = new(Model)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = getModelParametersToVertex
		fromConverter = modelFromVertex
	} else {
		toConverter = getModelParametersToMldev
		fromConverter = modelFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{name}", urlParams)
	} else {
		path, err = formatMap("{name}", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodGet, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) list(ctx context.Context, config *ListModelsConfig) (*ListModelsResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var response = new(ListModelsResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = listModelsParametersToVertex
		fromConverter = listModelsResponseFromVertex
	} else {
		toConverter = listModelsParametersToMldev
		fromConverter = listModelsResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{modelsUrl}", urlParams)
	} else {
		path, err = formatMap("{modelsUrl}", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodGet, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) Update(ctx context.Context, model string, config *UpdateModelConfig) (*Model, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var response = new(Model)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = updateModelParametersToVertex
		fromConverter = modelFromVertex
	} else {
		toConverter = updateModelParametersToMldev
		fromConverter = modelFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}", urlParams)
	} else {
		path, err = formatMap("{name}", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPatch, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) Delete(ctx context.Context, model string, config *DeleteModelConfig) (*DeleteModelResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var response = new(DeleteModelResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = deleteModelParametersToVertex
		fromConverter = deleteModelResponseFromVertex
	} else {
		toConverter = deleteModelParametersToMldev
		fromConverter = deleteModelResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{name}", urlParams)
	} else {
		path, err = formatMap("{name}", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodDelete, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) CountTokens(ctx context.Context, model string, contents []*Content, config *CountTokensConfig) (*CountTokensResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "contents": contents, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}

	var response = new(CountTokensResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = countTokensParametersToVertex
		fromConverter = countTokensResponseFromVertex
	} else {
		toConverter = countTokensParametersToMldev
		fromConverter = countTokensResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}:countTokens", urlParams)
	} else {
		path, err = formatMap("{model}:countTokens", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

func (m Models) ComputeTokens(ctx context.Context, model string, contents []*Content, config *ComputeTokensConfig) (*ComputeTokensResponse, error) {
	parameterMap := make(map[string]any)

	kwargs := map[string]any{"model": model, "contents": contents, "config": config}
	deepMarshal(kwargs, &parameterMap)

	var httpOptions *HTTPOptions
	if config == nil {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, nil)
	} else {
		httpOptions = mergeHTTPOptions(m.apiClient.clientConfig, config.HTTPOptions)
		config.HTTPOptions = nil
	}
	if m.apiClient.clientConfig.Backend == BackendGeminiAPI {
		return nil, fmt.Errorf("method ComputeTokens is only supported in the Vertex AI client. You can choose to use Vertex AI by setting ClientConfig.Backend to BackendVertexAI.")
	}

	var response = new(ComputeTokensResponse)
	var responseMap map[string]any
	var fromConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	var toConverter func(*apiClient, map[string]any, map[string]any) (map[string]any, error)
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		toConverter = computeTokensParametersToVertex
		fromConverter = computeTokensResponseFromVertex
	} else {
		toConverter = computeTokensParametersToMldev
		fromConverter = computeTokensResponseFromMldev
	}

	body, err := toConverter(m.apiClient, parameterMap, nil)
	if err != nil {
		return nil, err
	}
	var path string
	var urlParams map[string]any
	if _, ok := body["_url"]; ok {
		urlParams = body["_url"].(map[string]any)
		delete(body, "_url")
	}
	if m.apiClient.clientConfig.Backend == BackendVertexAI {
		path, err = formatMap("{model}:computeTokens", urlParams)
	} else {
		path, err = formatMap("None", urlParams)
	}
	if err != nil {
		return nil, fmt.Errorf("invalid url params: %#v.\n%w", urlParams, err)
	}
	if _, ok := body["_query"]; ok {
		query, err := createURLQuery(body["_query"].(map[string]any))
		if err != nil {
			return nil, err
		}
		path += "?" + query
		delete(body, "_query")
	}

	if _, ok := body["config"]; ok {
		delete(body, "config")
	}
	responseMap, err = sendRequest(ctx, m.apiClient, path, http.MethodPost, body, httpOptions)
	if err != nil {
		return nil, err
	}
	responseMap, err = fromConverter(m.apiClient, responseMap, nil)
	if err != nil {
		return nil, err
	}
	err = mapToStruct(responseMap, response)
	if err != nil {
		return nil, err
	}
	return response, nil
}

// GenerateContent calls the GenerateContent method on the model.
func (m Models) GenerateContent(ctx context.Context, model string, contents []*Content, config *GenerateContentConfig) (*GenerateContentResponse, error) {
	if config != nil {
		config.setDefaults()
	}
	return m.generateContent(ctx, model, contents, config)
}

// GenerateContentStream calls the GenerateContentStream method on the model.
func (m Models) GenerateContentStream(ctx context.Context, model string, contents []*Content, config *GenerateContentConfig) iter.Seq2[*GenerateContentResponse, error] {
	if config != nil {
		config.setDefaults()
	}
	return m.generateContentStream(ctx, model, contents, config)
}

func (m Models) List(ctx context.Context, config *ListModelsConfig) (Page[Model], error) {
	listFunc := func(ctx context.Context, config map[string]any) ([]*Model, string, error) {
		var c ListModelsConfig
		if err := mapToStruct(config, &c); err != nil {
			return nil, "", err
		}
		if c.QueryBase == nil {
			c.QueryBase = Ptr(true)
		}
		if m.apiClient.clientConfig.Backend == BackendVertexAI && !*c.QueryBase {
			if c.Filter != "" {
				c.Filter += "&filter="
			}
			c.Filter += "labels.tune-type:*"
		}
		resp, err := m.list(ctx, &c)
		if err != nil {
			return nil, "", err
		}
		return resp.Models, resp.NextPageToken, nil
	}
	c := make(map[string]any)
	deepMarshal(config, &c)
	return newPage(ctx, "models", c, listFunc)
}

func (m Models) All(ctx context.Context) iter.Seq2[*Model, error] {
	listFunc := func(ctx context.Context, _ map[string]any) ([]*Model, string, error) {
		resp, err := m.list(ctx, &ListModelsConfig{QueryBase: Ptr(true)})
		if err != nil {
			return nil, "", err
		}
		return resp.Models, resp.NextPageToken, nil
	}
	p, err := newPage(ctx, "models", map[string]any{}, listFunc)
	if err != nil {
		return yieldErrorAndEndIterator[Model](err)
	}
	return p.all(ctx)
}

// UpscaleImage calls the upscaleImage method on the model.
func (m Models) UpscaleImage(ctx context.Context, model string, image *Image, upscaleFactor string, config *UpscaleImageConfig) (*UpscaleImageResponse, error) {
	// Convert to API config.
	apiConfig := &upscaleImageAPIConfig{Mode: "upscale", NumberOfImages: 1}

	if config != nil {
		apiConfig.OutputMIMEType = config.OutputMIMEType
		apiConfig.OutputCompressionQuality = config.OutputCompressionQuality
		apiConfig.IncludeRAIReason = config.IncludeRAIReason
	}

	return m.upscaleImage(ctx, model, image, upscaleFactor, apiConfig)
}

// EditImage calls the EditImage method on the model.
func (m Models) EditImage(ctx context.Context, model, prompt string, referenceImages []ReferenceImage, config *EditImageConfig) (*EditImageResponse, error) {
	refImages := make([]*referenceImageAPI, len(referenceImages))
	for i, img := range referenceImages {
		refImages[i] = img.referenceImageAPI()
	}
	return m.editImage(ctx, model, prompt, refImages, config)
}
